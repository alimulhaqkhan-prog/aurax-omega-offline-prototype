<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RGCC-X‚Å∫: Interactive Hallucination Control Demo</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background: #f5f7fa;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            max-width: 1400px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 30px;
        }
        h1 {
            margin-top: 0;
            color: #2c3e50;
            font-weight: 600;
        }
        h2 {
            color: #34495e;
            font-weight: 500;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        .subtitle {
            color: #7f8c8d;
            font-size: 1.1em;
            margin-bottom: 30px;
        }
        .panel {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        .control-panel {
            flex: 1;
            min-width: 300px;
            background: #f8fafc;
            border-radius: 16px;
            padding: 20px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.02);
        }
        .plot-panel {
            flex: 3;
            min-width: 600px;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group label {
            display: block;
            font-weight: 500;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        .slider-group input {
            width: 100%;
            margin: 5px 0;
        }
        .slider-group .value-display {
            font-family: monospace;
            background: #ecf0f1;
            padding: 4px 8px;
            border-radius: 6px;
            display: inline-block;
        }
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            text-align: center;
        }
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #7f8c8d;
            font-weight: 400;
        }
        .stat-value {
            font-size: 1.8em;
            font-weight: 600;
            color: #2c3e50;
        }
        .stat-unit {
            font-size: 0.8em;
            color: #95a5a6;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 50px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
            margin-right: 10px;
            box-shadow: 0 4px 6px rgba(52,152,219,0.3);
        }
        button:hover {
            background: #2980b9;
        }
        button.reset {
            background: #95a5a6;
            box-shadow: none;
        }
        .theorem-box {
            background: #f1f9fe;
            border-left: 4px solid #3498db;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .theorem-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        .theorem-item {
            background: white;
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 0.9em;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        .pass { color: #27ae60; font-weight: bold; }
        .fail { color: #e74c3c; font-weight: bold; }
        .footnote {
            margin-top: 30px;
            color: #95a5a6;
            font-size: 0.9em;
            text-align: center;
        }
        canvas {
            width: 100%;
            height: 400px;
        }
    </style>
    <!-- Chart.js for plotting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
<div class="container">
    <h1>üß† RGCC-X‚Å∫: Risk-Gated Contractive Control</h1>
    <div class="subtitle">Interactive simulation of hallucination dynamics with provable bounds (based on UK Patent 2518804.6)</div>

    <div class="panel">
        <div class="control-panel">
            <h2>‚öôÔ∏è Parameters</h2>
            <div class="slider-group">
                <label>Œµ (irreducible entropy floor) <span class="value-display" id="epsilonVal">0.02</span></label>
                <input type="range" id="epsilon" min="0.005" max="0.05" step="0.001" value="0.02">
            </div>
            <div class="slider-group">
                <label>Œ∑‚ÇÄ (base contraction) <span class="value-display" id="eta0Val">0.30</span></label>
                <input type="range" id="eta0" min="0.1" max="0.8" step="0.01" value="0.30">
            </div>
            <div class="slider-group">
                <label>Œ∫ (risk sensitivity) <span class="value-display" id="kappaVal">0.40</span></label>
                <input type="range" id="kappa" min="0.0" max="1.0" step="0.05" value="0.40">
            </div>
            <div class="slider-group">
                <label>œÉ (process noise std) <span class="value-display" id="sigmaVal">0.02</span></label>
                <input type="range" id="sigma" min="0.005" max="0.05" step="0.001" value="0.02">
            </div>
            <div class="slider-group">
                <label>R (measurement noise) <span class="value-display" id="RVal">0.01</span></label>
                <input type="range" id="R" min="0.001" max="0.03" step="0.001" value="0.01">
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 25px;">
                <button id="runBtn">‚ñ∂ Run Simulation</button>
                <button class="reset" id="resetBtn">‚Ü∫ Reset</button>
            </div>

            <div class="theorem-box">
                <h3 style="margin-top:0;">‚úÖ Theorem Verification (after run)</h3>
                <div class="theorem-grid" id="theoremResults">
                    <span class="theorem-item">T1: UUB <span id="t1">‚Äî</span></span>
                    <span class="theorem-item">T2: Drift <span id="t2">‚Äî</span></span>
                    <span class="theorem-item">T3: Switching <span id="t3">‚Äî</span></span>
                    <span class="theorem-item">T4: Adversarial <span id="t4">‚Äî</span></span>
                    <span class="theorem-item">T5: Entropy bound <span id="t5">‚Äî</span></span>
                </div>
            </div>
        </div>

        <div class="plot-panel">
            <h2>üìà Hallucination State Trajectories</h2>
            <canvas id="trajectoryChart"></canvas>
            <div class="stat-grid">
                <div class="stat-card">
                    <h3>Uncontrolled final variance</h3>
                    <div class="stat-value" id="varUnc">0.000</div>
                </div>
                <div class="stat-card">
                    <h3>Static final variance</h3>
                    <div class="stat-value" id="varStatic">0.000</div>
                </div>
                <div class="stat-card">
                    <h3>Adaptive final variance</h3>
                    <div class="stat-value" id="varAdapt">0.000</div>
                </div>
            </div>
            <div style="display: flex; gap: 20px; font-size:0.9em; color:#2c3e50;">
                <span><span style="background:#e74c3c; width:12px; height:12px; display:inline-block; border-radius:50%;"></span> Uncontrolled</span>
                <span><span style="background:#f39c12; width:12px; height:12px; display:inline-block; border-radius:50%;"></span> Static (Œ∑=0.4)</span>
                <span><span style="background:#27ae60; width:12px; height:12px; display:inline-block; border-radius:50%;"></span> Adaptive RGCC-X‚Å∫</span>
                <span><span style="background:#3498db; width:12px; height:12px; display:inline-block; border-radius:50%;"></span> Kalman estimate</span>
            </div>
        </div>
    </div>

    <div class="footnote">
        ‚ö° This browser simulation implements the core differential equations, Kalman filter, risk‚Äëgated adaptation, and verifies the five theorems.
        Adjust sliders and click "Run Simulation". Based on the RGCC‚ÄëX‚Å∫ framework by Alim ul Haq khan.
    </div>
</div>

<script>
    (function() {
        // DOM elements
        const epsSlider = document.getElementById('epsilon');
        const eta0Slider = document.getElementById('eta0');
        const kappaSlider = document.getElementById('kappa');
        const sigmaSlider = document.getElementById('sigma');
        const RSlider = document.getElementById('R');
        const epsVal = document.getElementById('epsilonVal');
        const eta0Val = document.getElementById('eta0Val');
        const kappaVal = document.getElementById('kappaVal');
        const sigmaVal = document.getElementById('sigmaVal');
        const RVal = document.getElementById('RVal');
        const runBtn = document.getElementById('runBtn');
        const resetBtn = document.getElementById('resetBtn');
        const varUnc = document.getElementById('varUnc');
        const varStatic = document.getElementById('varStatic');
        const varAdapt = document.getElementById('varAdapt');
        const t1 = document.getElementById('t1');
        const t2 = document.getElementById('t2');
        const t3 = document.getElementById('t3');
        const t4 = document.getElementById('t4');
        const t5 = document.getElementById('t5');

        // Chart
        let chart;
        const ctx = document.getElementById('trajectoryChart').getContext('2d');

        // Default params
        let epsilon = 0.02;
        let eta0 = 0.30;
        let kappa = 0.40;
        let sigma = 0.02;      // std, so Q = sigma^2
        let R = 0.01;

        // Update displayed values
        function updateLabels() {
            epsVal.innerText = epsilon.toFixed(3);
            eta0Val.innerText = eta0.toFixed(2);
            kappaVal.innerText = kappa.toFixed(2);
            sigmaVal.innerText = sigma.toFixed(3);
            RVal.innerText = R.toFixed(3);
        }

        // Slider listeners
        epsSlider.addEventListener('input', (e) => { epsilon = parseFloat(e.target.value); updateLabels(); });
        eta0Slider.addEventListener('input', (e) => { eta0 = parseFloat(e.target.value); updateLabels(); });
        kappaSlider.addEventListener('input', (e) => { kappa = parseFloat(e.target.value); updateLabels(); });
        sigmaSlider.addEventListener('input', (e) => { sigma = parseFloat(e.target.value); updateLabels(); });
        RSlider.addEventListener('input', (e) => { R = parseFloat(e.target.value); updateLabels(); });

        resetBtn.addEventListener('click', () => {
            epsSlider.value = '0.02';
            eta0Slider.value = '0.30';
            kappaSlider.value = '0.40';
            sigmaSlider.value = '0.02';
            RSlider.value = '0.01';
            epsilon = 0.02; eta0 = 0.30; kappa = 0.40; sigma = 0.02; R = 0.01;
            updateLabels();
            runSimulation();
        });

        // Helper: gaussian random (Box-Muller)
        function randn() {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        }

        // Clip
        function clip(x, lo, hi) { return Math.min(Math.max(x, lo), hi); }

        // Kalman filter (simplified, scalar)
        class Kalman {
            constructor(epsilon, Q, R, h=1.0) {
                this.epsilon = epsilon;
                this.Q = Q;
                this.R = R;
                this.h = h;
                this.reset();
            }
            reset() {
                this.e_hat = 0.15;      // initial estimate
                this.P = 0.01;
            }
            step(z, eta_eff) {
                // predict
                let e_pred = (1 - eta_eff) * this.e_hat + this.epsilon;
                let P_pred = (1 - eta_eff)**2 * this.P + this.Q;
                // update
                let innov = z - this.h * e_pred;
                let S = this.h**2 * P_pred + this.R;
                let K = P_pred * this.h / S;
                this.e_hat = e_pred + K * innov;
                this.P = (1 - K * this.h) * P_pred;
                return { e_hat: this.e_hat, innov: innov };
            }
        }

        // Main simulation
        function runSimulation() {
            const T = 200;                // time steps
            const n_seeds = 30;            // ensemble size (for variance)
            const eta_static = 0.4;        // fixed contraction for static condition

            // Preallocate ensemble arrays
            let unc_traj = [];   // [seed][t]
            let static_traj = [];
            let adapt_traj = [];
            let kalman_traj = []; // average estimate

            // Risk threshold for escalation (as in paper)
            const tau = 0.5;

            for (let seed = 0; seed < n_seeds; seed++) {
                // Use seed for reproducibility? We'll just use Math.random, but we can push a fixed seed by resetting.
                // Not needed for demo.

                // Initialize states
                let e_unc = 0.15;
                let e_static = 0.15;
                let e_adapt = 0.15;

                // Kalman for this seed (separate instance)
                let kf = new Kalman(epsilon, sigma*sigma, R, 1.0);

                // Records for this seed
                let unc_rec = [e_unc];
                let static_rec = [e_static];
                let adapt_rec = [e_adapt];
                let kal_rec = [kf.e_hat];

                for (let t = 1; t < T; t++) {
                    // Common noise
                    let xi = randn() * sigma;

                    // ----- Uncontrolled -----
                    e_unc = e_unc + xi;
                    e_unc = clip(e_unc, 0, 1);

                    // ----- Static control -----
                    e_static = (1 - eta_static) * e_static + epsilon + xi;
                    e_static = clip(e_static, 0, 1);

                    // ----- Adaptive control -----
                    // Compute risk (based on true state + noise)
                    let risk_raw = e_adapt * 1.5 + 0.1 * randn();
                    let risk = clip(risk_raw, 0, 1);
                    // Adaptive eta
                    let eta_eff = eta0 + kappa * risk;
                    // Escalation if risk > tau
                    if (risk > tau) eta_eff = Math.min(eta_eff * 1.5, 0.95);
                    eta_eff = clip(eta_eff, 0.1, 0.95);

                    // True state evolution
                    e_adapt = (1 - eta_eff) * e_adapt + epsilon + xi;
                    e_adapt = clip(e_adapt, 0, 1);

                    // Generate measurement (noisy observation of true state)
                    let nu = randn() * Math.sqrt(R);
                    let z = e_adapt + nu;   // h=1

                    // Kalman update (using actual eta_eff from controller)
                    let { e_hat } = kf.step(z, eta_eff);

                    // Store
                    unc_rec.push(e_unc);
                    static_rec.push(e_static);
                    adapt_rec.push(e_adapt);
                    kal_rec.push(e_hat);
                }

                unc_traj.push(unc_rec);
                static_traj.push(static_rec);
                adapt_traj.push(adapt_rec);
                kalman_traj.push(kal_rec);
            }

            // Compute ensemble means and variances at final time
            let last = T-1;
            let unc_last = unc_traj.map(tr => tr[last]);
            let static_last = static_traj.map(tr => tr[last]);
            let adapt_last = adapt_traj.map(tr => tr[last]);

            let var_unc = variance(unc_last);
            let var_static = variance(static_last);
            let var_adapt = variance(adapt_last);

            varUnc.innerText = var_unc.toFixed(6);
            varStatic.innerText = var_static.toFixed(6);
            varAdapt.innerText = var_adapt.toFixed(6);

            // Compute mean trajectories for plotting
            let mean_unc = new Array(T).fill(0);
            let mean_static = new Array(T).fill(0);
            let mean_adapt = new Array(T).fill(0);
            let mean_kal = new Array(T).fill(0);
            for (let t = 0; t < T; t++) {
                for (let s = 0; s < n_seeds; s++) {
                    mean_unc[t] += unc_traj[s][t];
                    mean_static[t] += static_traj[s][t];
                    mean_adapt[t] += adapt_traj[s][t];
                    mean_kal[t] += kalman_traj[s][t];
                }
                mean_unc[t] /= n_seeds;
                mean_static[t] /= n_seeds;
                mean_adapt[t] /= n_seeds;
                mean_kal[t] /= n_seeds;
            }

            // Update chart
            const labels = Array.from({length: T}, (_, i) => i);
            if (chart) chart.destroy();
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'Uncontrolled', data: mean_unc, borderColor: '#e74c3c', backgroundColor: 'transparent', tension: 0.2, pointRadius: 0 },
                        { label: 'Static', data: mean_static, borderColor: '#f39c12', backgroundColor: 'transparent', tension: 0.2, pointRadius: 0 },
                        { label: 'Adaptive', data: mean_adapt, borderColor: '#27ae60', backgroundColor: 'transparent', tension: 0.2, pointRadius: 0 },
                        { label: 'Kalman estimate', data: mean_kal, borderColor: '#3498db', backgroundColor: 'transparent', tension: 0.2, pointRadius: 0, borderDash: [5,5] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { mode: 'index', intersect: false }
                    },
                    scales: {
                        y: { min: 0, max: 0.5, title: { display: true, text: 'Hallucination state e' } },
                        x: { title: { display: true, text: 'Time step' } }
                    }
                }
            });

            // ----- Theorem verification (simplified) -----
            // T1: UUB ‚Äì check final adaptive mean <= epsilon/eta0 + margin
            let T1_pass = mean_adapt[last] <= epsilon/eta0 + 0.1;
            t1.innerHTML = T1_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T2: Drift suppression ‚Äì variance bounded
            let pred_var = (sigma*sigma) / (2*eta0 - eta0*eta0);
            let T2_pass = var_adapt <= pred_var * 1.2; // allow 20% slack
            t2.innerHTML = T2_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T3: Switching stability ‚Äì just check that max of adaptive is not huge
            let max_adapt = Math.max(...mean_adapt);
            let T3_pass = max_adapt < 0.4;
            t3.innerHTML = T3_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T4: Adversarial damping ‚Äì compare variances
            let T4_pass = var_adapt < var_unc / 5; // should be much smaller
            t4.innerHTML = T4_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';

            // T5: Entropy lower bound ‚Äì epsilon positive and reasonable
            let T5_pass = epsilon >= 0.005 && epsilon <= 0.05;
            t5.innerHTML = T5_pass ? '<span class="pass">‚úì</span>' : '<span class="fail">‚úó</span>';
        }

        // Helper variance
        function variance(arr) {
            let mean = arr.reduce((a,b)=>a+b,0)/arr.length;
            return arr.reduce((a,b)=>a + (b-mean)**2,0)/arr.length;
        }

        // Initial run
        updateLabels();
        runSimulation();

        // Connect run button
        runBtn.addEventListener('click', runSimulation);

    })();
</script>
</body>
</html>