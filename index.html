<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AURA-X Œ© ‚Äì Offline Emotional Continuity Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Offline LLM package (WebLLM, for in-browser models ‚Äì future ready) -->
  <script type="module">
    import * as webllm from "https://esm.run/@mlc-ai/web-llm";
    window.webllm = webllm;
  </script>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    :root { --accent-color:#0ea5e9; }
    body{
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:
        radial-gradient(circle at 20% 0%, #1e293b 0, transparent 45%),
        radial-gradient(circle at 80% 0, #0ea5e9 0, transparent 40%),
        linear-gradient(145deg,#020617 0,#020617 40%,#020617 100%);
      color:#e5e7eb;
      min-height:100vh;
      display:flex;
      justify-content:center;
      padding:18px 10px;
    }
    .app{
      width:min(980px,98vw);
      background:rgba(2,6,23,.45);
      border:1px solid rgba(148,163,184,.18);
      border-radius:22px;
      overflow:hidden;
      box-shadow:0 20px 60px rgba(0,0,0,.45);
      backdrop-filter:blur(10px);
    }
    .top{
      padding:20px 18px 10px;
      border-bottom:1px solid rgba(148,163,184,.14);
      text-align:center;
      position:relative;
    }
    .brand{
      font-weight:800;
      letter-spacing:.5px;
      font-size:26px;
      color:#7dd3fc;
      text-shadow:0 0 22px rgba(14,165,233,.28);
    }
    .sub{
      opacity:.8;
      margin-top:2px;
      font-size:13px;
    }
    .ethic{
      margin:14px auto 12px;
      max-width:720px;
      border:1px solid rgba(251,191,36,.35);
      border-radius:14px;
      padding:10px 36px 9px 14px;
      color:#fbbf24;
      background:rgba(2,6,23,.35);
      box-shadow:inset 0 0 0 1px rgba(251,191,36,.08);
      font-size:14px;
      line-height:1.4;
      position:relative;
      overflow:hidden;
      transition:background .4s ease,border-color .4s ease,transform .4s ease,box-shadow .4s ease;
    }
    .ethicMain{font-weight:600;}
    .ethicMeta{
      font-size:11px;
      opacity:.8;
      margin-top:2px;
      display:none; /* ‚úÖ meta line default hidden */
    }
    .ethic.ethicPulse{
      animation:ethicPulse 1.1s ease;
    }
    @keyframes ethicPulse{
      0%{box-shadow:0 0 0 0 rgba(251,191,36,.55);transform:translateY(0);}
      45%{box-shadow:0 0 0 16px rgba(251,191,36,0);transform:translateY(-1px);}
      100%{box-shadow:0 0 0 0 rgba(251,191,36,0);transform:translateY(0);}
    }
    .faithCfgBtn{
      position:absolute;
      right:6px;
      top:4px;
      border:none;
      background:transparent;
      color:#fde68a;
      cursor:pointer;
      font-size:16px;
      line-height:1;
      display:none;
      -webkit-tap-highlight-color:transparent;
    }
    .faithCfgBtn.show{display:inline-flex;}
    .pill{
      margin:10px auto 0;
      max-width:760px;
      background:linear-gradient(90deg, rgba(14,165,233,.65), rgba(34,211,238,.45));
      border:1px solid rgba(125,211,252,.30);
      color:#0b1220;
      font-weight:800;
      letter-spacing:.6px;
      border-radius:999px;
      padding:14px 16px;
      text-transform:uppercase;
      box-shadow:0 12px 40px rgba(14,165,233,.22);
      position:relative;
    }
    .pill.faithGlow{
      border-color:rgba(251,191,36,.9);
      box-shadow:0 0 26px rgba(251,191,36,.75);
      background:linear-gradient(90deg, rgba(14,165,233,.6), rgba(251,191,36,.9));
    }
    .main{ padding:16px 16px 18px }
    .row{display:flex;gap:14px;flex-wrap:wrap;align-items:stretch}
    .leftCol{ flex:1 1 340px; min-width:300px }
    .rightCol{ flex:1 1 360px; min-width:320px }
    .card{
      background:rgba(2,6,23,.50);
      border:1px solid rgba(148,163,184,.16);
      border-radius:18px;
      padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      backdrop-filter:blur(10px);
    }
    .optionsBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(15,23,42,.55);
      color:#e5e7eb;
      cursor:pointer;
      user-select:none;
      margin:12px 0;
      -webkit-tap-highlight-color:transparent;
    }
    .optionsBtn:active{transform:scale(.99)}
    .gear{width:18px;height:18px;filter:drop-shadow(0 0 10px rgba(125,211,252,.25))}
    .console{
      margin-top:12px;
      height:230px;
      border-radius:16px;
      border:1px solid rgba(148,163,184,.14);
      background:rgba(0,0,0,.25);
      padding:14px;
      overflow:auto;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      font-size:14px;
      box-shadow:inset 0 0 0 1px rgba(125,211,252,.06);
      line-height:1.55;
      white-space:pre-wrap;
    }
    .line{display:block;margin:2px 0}
    .line.user{color:#a5b4fc;}
    .line.aura{color:#bbf7d0;}
    .line.sys{color:#fbbf24;font-size:12px;}
    .optionsMenu{
      position:fixed;
      left:12px;
      right:12px;
      top:120px;
      margin:0 auto;
      max-width:940px;
      background:rgba(2,6,23,.92);
      border:1px solid rgba(148,163,184,.18);
      border-radius:16px;
      padding:8px;
      display:none;
      z-index:9999;
      box-shadow:0 18px 45px rgba(0,0,0,.45);
      backdrop-filter:blur(10px);
      grid-template-columns:repeat(3,minmax(0,1fr));
      gap:8px;
      align-items:stretch;
    }
    .optionsMenu.show{display:grid}
    .menuItem{
      padding:8px 6px;
      border-radius:13px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:6px;
      color:#e5e7eb;
      border:1px solid rgba(148,163,184,.10);
      background:rgba(15,23,42,.55);
      user-select:none;
      min-height:58px;
    }
    .menuItem:active{transform:scale(.995)}

    /* Injected (v4.9): keep Sense tile below BM Recall so it doesn't cover other buttons */
    #optionsMenu #miSense{
      grid-column: 2;
      grid-row: 4;
    }
    .menuLeft{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      font-weight:800;
      font-size:12.5px;
    }
    .menuIcon{
      width:18px;
      height:18px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .menuRight{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:44px;
    }
    .pillOn,.pillOff,.pillMid{
      font-size:10px;
      padding:4px 7px;
      border-radius:999px;
      font-weight:900;
      text-transform:lowercase;
      border:1px solid transparent;
    }
    .pillOn{
      background:rgba(34,197,94,.18);
      border-color:rgba(34,197,94,.24);
      color:#bbf7d0;
    }
    .pillOff{
      background:rgba(239,68,68,.12);
      border-color:rgba(239,68,68,.22);
      color:#fecaca;
    }
    .pillMid{
      background:rgba(14,165,233,.14);
      border-color:rgba(14,165,233,.20);
      color:#bae6fd;
      opacity:.95;
    }
    .chatWrap{
      margin-top:0;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(148,163,184,.14);
      background:rgba(2,6,23,.45);
    }
    .reactionBar{
      margin-top:0;
      margin-bottom:6px;
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:10px;
      font-size:18px;
      opacity:.9;
    }
    .reactBtn{
      border:none;
      background:transparent;
      cursor:pointer;
      padding:4px;
      line-height:1;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color:transparent;
    }
    .reactBtn:active{transform:scale(.9)}
    .liveCapsule{
      margin:4px 0 10px;
      width:100%;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.18);
      background:rgba(2,6,23,.55);
      padding:8px 12px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      font-size:12px;
      color:#dbeafe;
      box-shadow:inset 0 0 0 1px rgba(125,211,252,.06);
    }
    .liveCapsule b{ color:#7dd3fc; font-weight:900 }
    .faithBubble{
      margin:4px 0 10px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(251,191,36,.16);
      border:1px solid rgba(251,191,36,.4);
      display:none;
      align-items:center;
      gap:8px;
      font-size:12px;
      color:#facc15;
      cursor:pointer;
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      transition:opacity .25s ease, transform .25s ease;
      width:100%;
    }
    .faithBubble.show{
      display:flex;
      opacity:1;
      transform:translateY(0);
    }
    .fbIcon{font-size:18px;}
    .fbText{flex:1;line-height:1.3;}
    .fbTitle{font-weight:800;}
    .fbMeta{opacity:.85;}
    .fbClose{
      border:none;
      background:transparent;
      color:#fed7aa;
      font-size:16px;
      cursor:pointer;
      padding:0 4px;
      line-height:1;
    }
    .faithBubble.pulse{
      animation: faithPulse 1.4s infinite;
    }
    .faithBubble.flying{
      animation: faithFlyUp 2.1s ease-in-out forwards, faithBlink 1s ease-in-out 0s 2;
    }
    @keyframes faithPulse{
      0%   { box-shadow: 0 0 0 0 rgba(251,191,36,.55); }
      100% { box-shadow: 0 0 0 18px rgba(251,191,36,0); }
    }
    @keyframes faithFlyUp{
      0%   { transform:translateY(0); opacity:1; }
      60%  { transform:translateY(-140px); opacity:1; }
      100% { transform:translateY(-180px); opacity:0; }
    }
    @keyframes faithBlink{
      0%{box-shadow:0 0 0 0 rgba(251,191,36,.4);}
      50%{box-shadow:0 0 18px 4px rgba(251,191,36,.95);}
      100%{box-shadow:0 0 0 0 rgba(251,191,36,0);}
    }
    .inputRow{display:flex;gap:10px;align-items:flex-end}
    .input{
      flex:1;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.18);
      background:rgba(2,6,23,.55);
      color:#e5e7eb;
      padding:12px 14px;
      outline:none;
      font-size:14px;
    }
    .send{
      border:none;
      border-radius:999px;
      background:linear-gradient(90deg, var(--accent-color, #0ea5e9), rgba(34,211,238,.55));
      color:#0b1220;
      font-weight:900;
      padding:12px 18px;
      cursor:pointer;
      min-width:88px;
      box-shadow:0 12px 30px rgba(14,165,233,.18);
      -webkit-tap-highlight-color:transparent;
    }
    .send:active{transform:scale(.99)}
    .formula{
      margin-top:10px;
      opacity:.8;
      font-size:12px;
      text-align:center;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      color:#dbeafe;
    }
    .toastBubble{
      position:fixed;
      bottom:18px;
      left:50%;
      transform:translate(-50%,10px);
      padding:6px 14px;
      border-radius:999px;
      background:rgba(15,23,42,.95);
      color:#e5e7eb;
      font-size:12px;
      border:1px solid rgba(148,163,184,.4);
      box-shadow:0 12px 30px rgba(0,0,0,.5);
      opacity:0;
      pointer-events:none;
      z-index:10000;
      transition:opacity .18s ease, transform .18s ease;
    }
    .toastBubble.show{
      opacity:1;
      transform:translate(-50%,0);
    }
    .modalOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:18px 12px;
      z-index:9999;
    }
    .modalOverlay.show{display:flex}
    .modal{
      width:min(860px,96vw);
      border-radius:18px;
      overflow:hidden;
      background:rgba(250,250,250,.93);
      color:#0b1220;
      border:1px solid rgba(15,23,42,.18);
      box-shadow:0 30px 80px rgba(0,0,0,.35);
      backdrop-filter:blur(12px);
    }
    .modalHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      background:rgba(255,255,255,.75);
      border-bottom:1px solid rgba(15,23,42,.10);
      font-weight:800;
    }
    .modalHeader small{font-weight:600;opacity:.7}
    .closeX{
      border:none;
      background:transparent;
      font-size:22px;
      cursor:pointer;
      line-height:1;
      padding:0 4px;
      opacity:.75;
    }
    .modalBody{
      padding:14px;
      max-height:70vh;
      overflow:auto;
    }
    .chipsWrap{margin-top:10px;display:flex;flex-wrap:wrap;gap:10px}
    .chip{
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,.16);
      background:rgba(255,255,255,.9);
      font-weight:800;
      cursor:pointer;
      -webkit-tap-highlight-color:transparent;
    }
    .chip.active{
      background:#0f172a;
      color:#fff;
      border-color:rgba(15,23,42,.2);
      box-shadow:0 12px 30px rgba(2,6,23,.12);
    }
    .btn{
      border:none;
      cursor:pointer;
      padding:10px 14px;
      border-radius:12px;
      font-weight:900;
      -webkit-tap-highlight-color:transparent;
      font-size:12px;
    }
    .btnBlue{background:rgba(59,130,246,.16);border:1px solid rgba(59,130,246,.22)}
    .btnDark{background:rgba(2,6,23,.92);color:#fff}
    .btnRed{background:rgba(239,68,68,.14);border:1px solid rgba(239,68,68,.22);color:#7f1d1d}
    .btnGreen{background:rgba(34,197,94,.18);border:1px solid rgba(34,197,94,.25);color:#064e2a}
    .bmCard{
      border-radius:16px;
      border:1px solid rgba(15,23,42,.12);
      background:rgba(255,255,255,.85);
      padding:12px;
      margin-top:12px;
    }
    .bmTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .bmTop .title{
      font-weight:900;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .bmSub{font-size:12px;opacity:.7;margin-top:2px}
    .bmText{
      width:100%;
      min-height:240px;
      border-radius:14px;
      border:1px solid rgba(15,23,42,.18);
      padding:12px;
      outline:none;
      resize:vertical;
      background:#fff;
      font-size:14px;
      line-height:1.45;
    }
    .bmActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:10px;
      justify-content:flex-start;
    }
    .intelEditInput, .intelEditArea{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(15,23,42,.18);
      padding:10px 12px;
      font-size:14px;
      outline:none;
      background:#fff;
    }
    .intelEditArea{
      min-height:90px;
      resize:vertical;
      line-height:1.4;
      margin-top:6px;
    }
    .intelCard{
      border-radius:12px;
      border:1px solid rgba(15,23,42,.12);
      background:#f9fafb;
      padding:10px;
      margin-top:8px;
      font-size:13px;
    }
    .intelTop{
      display:flex;
      justify-content:space-between;
      gap:8px;
      margin-bottom:4px;
    }
    .intelQ{font-weight:700;}
    .intelA{margin-top:2px;white-space:pre-wrap;}
    .intelMeta{font-size:11px;opacity:.65;margin-top:2px;}
    .intelButtons{display:flex;gap:6px;flex-wrap:wrap;justify-content:flex-end;margin-top:6px;}
    .intelEditBlock{
      margin-top:8px;
      border-radius:10px;
      border:1px dashed rgba(15,23,42,.18);
      padding:8px;
      background:#fff;
    }
    #modalHistory .modalBody{background:#f8fafc;}
    #historyBox{
      margin-top:4px;
      border-radius:14px;
      padding:4px 0;
      max-height:60vh;
      overflow:auto;
    }
    .historyLine{
      padding:8px 10px;
      font-size:12px;
      margin-bottom:6px;
      border-radius:12px;
      background:#f9fafb;
      border:1px solid rgba(148,163,184,.45);
      color:#0b1120;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:6px;
    }
    .historyText{flex:1;white-space:pre-wrap;}
    .historyLock{
      border:none;
      background:transparent;
      cursor:pointer;
      font-size:15px;
      line-height:1;
      padding:0 2px;
    }
    .bmItem{
      margin-top:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid rgba(148,163,184,.5);
      background:#f9fafb;
      cursor:pointer;
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:6px;
    }
    .bmItemTitle{font-weight:700;}
    .bmItemMeta{opacity:.65;font-size:11px;}
    #dreamOverlay{
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 10% 0%, #020617 0, transparent 45%),
        radial-gradient(circle at 90% 0, #0ea5e9 0, transparent 45%),
        rgba(2,6,23,.96);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:9500;
      backdrop-filter:blur(16px);
    }
    #dreamOverlay.show{display:flex;}
     #dreamCanvas{
       position:absolute;
       inset:0;
       width:100%;
       height:100%;
       pointer-events:none;
       z-index:1;
     }
     #dreamFilmCanvas{
       position:absolute;
       left:50%;
       top:50%;
       transform:translate(-50%,-50%);
       width:min(720px,86vw);
       height:auto;
       aspect-ratio:16/9;
       border-radius:34px;
       pointer-events:none;
       z-index:2;
       opacity:0;
       filter:blur(.2px) saturate(1.08);
       /* Feather edges so video never looks like a hard rectangle */
       -webkit-mask-image: radial-gradient(closest-side, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
       mask-image: radial-gradient(closest-side, rgba(0,0,0,1) 60%, rgba(0,0,0,0) 100%);
       mix-blend-mode:screen;
     }
     #dreamFilmCanvas.show{
       opacity:.92;
       transition:opacity .6s ease;
     }
     #dreamBmBubble{
       position:absolute;
       left:50%;
       top:16%;
       transform:translate(-50%,-50%);
       max-width:min(760px,92vw);
       padding:10px 14px;
       border-radius:999px;
       border:1px solid rgba(148,163,184,.22);
       background:linear-gradient(90deg, rgba(2,6,23,.35), rgba(15,23,42,.28));
       color:#e0f2fe;
       font-weight:800;
       font-size:12px;
       letter-spacing:.2px;
       line-height:1.25;
       text-shadow:0 0 18px rgba(125,211,252,.18);
       box-shadow:0 14px 40px rgba(0,0,0,.35);
       opacity:0;
       pointer-events:none;
       z-index:3;
       backdrop-filter:blur(10px);
       -webkit-mask-image: radial-gradient(closest-side, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 100%);
       mask-image: radial-gradient(closest-side, rgba(0,0,0,1) 70%, rgba(0,0,0,0) 100%);
     }
     #dreamBmBubble.show{
       opacity:1;
       transition:opacity .35s ease, transform .35s ease;
     }
     .dreamInner{ position:relative; z-index:4; }

        .dreamInner{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:16px;
      text-align:center;
      padding:20px 18px;
      transition:opacity .6s ease, transform .6s ease, filter .6s ease;
    }
    #dreamOverlay.intro .dreamInner{
      opacity:1;
      transform:translateY(0) scale(1);
      filter:none;
      pointer-events:auto;
    }
    #dreamOverlay.deep .dreamInner{
      opacity:0;
      transform:translateY(18px) scale(.98);
      filter:blur(14px);
      pointer-events:none;
    }
    .dreamOrb{
      width:120px;
      height:120px;
      border-radius:999px;
      background:
        radial-gradient(circle at 30% 20%, #ffffff, #7dd3fc 40%, transparent 70%);
      border:2px solid rgba(125,211,252,.9);
      box-shadow:0 0 40px rgba(56,189,248,.8);
      animation:dreamPulse 3.5s ease-in-out infinite;
    }
    .dreamTitle{
      font-weight:800;
      font-size:18px;
      color:#e0f2fe;
    }
    .dreamSub{
      max-width:420px;
      font-size:13px;
      color:#bae6fd;
      opacity:.9;
    }
    .dreamMeta{
      margin-top:4px;
      font-size:11px;
      color:#93c5fd;
      opacity:.85;
    }
    @keyframes dreamPulse{
      0%{transform:translateY(0) scale(1);}
      50%{transform:translateY(-6px) scale(1.03);}
      100%{transform:translateY(0) scale(1);}
    }
    #imagePreviewArea{
      display:none;
      margin:6px 2px 2px;
      text-align:center;
      font-size:10px;
      opacity:.8;
    }
    #imgPrev{
      max-height:90px;
      border-radius:10px;
      border:2px solid var(--accent-color);
      margin-bottom:2px;
    }

    .visionList{
      margin-top:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
      text-align:left;
      font-size:12px;
      opacity:1;
    }
    .visionItem{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(148,163,184,.22);
      background:rgba(15,23,42,.35);
    }
    .visionIcon{
      width:34px;
      height:34px;
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      background:rgba(2,6,23,.55);
      border:1px solid rgba(148,163,184,.18);
      flex:0 0 auto;
    }
    .visionMeta{
      flex:1 1 auto;
      min-width:0;
    }
    .visionName{
      font-weight:600;
      color:#e5e7eb;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .visionSub{
      color:rgba(226,232,240,.78);
      margin-top:2px;
      font-size:11px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .visionRemove{
      flex:0 0 auto;
      border:1px solid rgba(244,63,94,.35);
      background:rgba(244,63,94,.10);
      color:#fecdd3;
      border-radius:999px;
      padding:6px 10px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      font-size:12px;
    }
    .visionThumb{
      width:34px;height:34px;border-radius:10px;object-fit:cover;
      border:1px solid rgba(148,163,184,.20);
      flex:0 0 auto;
    }

    body.theme-golden .ethic{
      border-color: rgba(251,191,36,.7);
      background: rgba(251,191,36,.06);
    }
    .@media-fix{}
    @media (max-width:760px){
      .console{height:240px}
      .optionsMenu{top:112px}
    }
    @media (max-width:420px){
      .brand{font-size:22px}
      .pill{font-size:14px}
      .ethic{font-size:13px}
      .console{height:260px}
      .optionsMenu{
        gap:6px;
        padding:7px;
        grid-template-columns:repeat(3,minmax(0,1fr));
      }
      .menuItem{min-height:52px;padding:6px 4px;}
      .menuLeft{font-size:11px}
      .pillOn,.pillOff,.pillMid{font-size:9.5px;padding:4px 6px;}
      .reactionBar{font-size:16px;gap:8px;}
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="brand">AURA-X Œ©</div>
      <div class="sub">
        Offline emotional continuity engine (prototype)<br>
        TM = user inputs only ¬∑ Internal layers keep continuity and emotional trajectory.
      </div>
      <div class="ethic" id="ethicBox">
        <div class="ethicMain" id="ethicMain">
          Universal ethic: avoid actions that grow negative emotions in you or others.
          Move gently toward choices that increase shared positive feeling for everyone.
        </div>
        <div class="ethicMeta" id="ethicMeta"></div><!-- ‚úÖ empty by default -->
        <button id="faithCfgBtn" class="faithCfgBtn" title="Faith live bar settings">üîò</button>
      </div>
      <div class="pill">EMOTIONAL CONTINUITY ENGINE ‚Äî ACTIVE</div>
    </div>
    <div class="main">
      <div class="row">
        <!-- LEFT -->
        <div class="leftCol">
          <div class="card">
            <div class="optionsBtn" id="btnOptions">
              <svg class="gear" viewBox="0 0 24 24" fill="none">
                <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z"
                      stroke="#7dd3fc" stroke-width="2"/>
                <path d="M19.4 15a8.2 8.2 0 0 0 .1-2l2-1.5-2-3.5-2.4 1a8.5 8.5 0 0 0-1.7-1l-.4-2.6h-4l-.4 2.6a8.5 8.5 0 0 0-1.7 1l-2.4-1-2 3.5 2 1.5a8.2 8.2 0 0 0 .1 2L2.7 16.5l2 3.5 2.4-1a8.5 8.5 0 0 0 1.7 1l.4 2.6h4l.4-2.6a8.5 8.5 0 0 0 1.7-1l2.4 1 2-3.5L19.4 15Z"
                      stroke="#7dd3fc" stroke-width="1.6" opacity=".9"/>
              </svg>
              <span>Options</span>
            </div>
            <div class="optionsMenu" id="optionsMenu">
              <div class="menuItem" id="miVoice">
                <div class="menuLeft"><span class="menuIcon">üé§</span><span>Voice</span></div>
                <div class="menuRight"><span class="pillOff" id="voicePill">off</span></div>
              </div>
              <div class="menuItem" id="miIntel">
                <div class="menuLeft"><span class="menuIcon">üß†</span><span>Intelligence</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
              <div class="menuItem" id="miLearn">
                <div class="menuLeft"><span class="menuIcon">üìö</span><span>Learning</span></div>
                <div class="menuRight"><span class="pillOn" id="learnPill">on</span></div>
              </div>
              <div class="menuItem" id="miSeed">
                <div class="menuLeft"><span class="menuIcon">üå±</span><span>Feed</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
              <div class="menuItem" id="miFaith">
                <div class="menuLeft"><span class="menuIcon">üïä</span><span>Faith</span></div>
                <div class="menuRight"><span class="pillOff" id="faithLabel">none</span></div>
              </div>
              <div class="menuItem" id="miIdentity">
                <div class="menuLeft"><span class="menuIcon">ü™™</span><span>Identity</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
              <div class="menuItem" id="miLLM">
                <div class="menuLeft"><span class="menuIcon">ü§ñ</span><span>LLM</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
              <div class="menuItem" id="miBMRecall">
                <div class="menuLeft"><span class="menuIcon">üìò</span><span>BM Recall</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
              <div class="menuItem" id="miHistory">
                <div class="menuLeft"><span class="menuIcon">üìú</span><span>History</span></div>
                <div class="menuRight"><span class="pillMid">open</span></div>
              </div>
            
              <div class="menuItem" id="miSense">
                <div class="menuLeft"><span class="menuIcon">üëÅÔ∏è</span><span>Sense</span></div>
                <div class="menuRight"><span class="pillMid" id="sensePill">idle</span></div>
              </div>
</div>
            <div class="console" id="console"></div>
          </div>
        </div>
        <!-- RIGHT -->
        <div class="rightCol">
          <div class="chatWrap">
            <div class="reactionBar" id="reactionBar">
              <button class="reactBtn" id="btnLikeLast" title="Save to Intelligence (like)">üëç</button>
              <button class="reactBtn" id="btnDislikeLast" title="Mark incorrect & teach new answer">üëé</button>
              <button class="reactBtn" id="btnSpeakLast" title="Play voice for last answer">üîä</button>
              <button class="reactBtn" id="btnShareLast" title="Copy question + answer">üîó</button>
            </div>
            <div class="liveCapsule">
              <span><b>E0</b>: <span id="cE0">0.000</span></span><span>¬∑</span>
              <span><b>TM</b>: <span id="cTM">0.00</span></span><span>¬∑</span>
              <span><b>BM</b>: <span id="cBM">0.00</span></span><span>¬∑</span>
              <span><b>C</b>: <span id="cCont">0.850</span></span>
            </div>
            <div class="faithBubble" id="faithBubble">
              <div class="fbIcon">üí≠</div>
              <div class="fbText">
                <div class="fbTitle" id="faithBubbleTitle">Faith reflection bubble</div>
                <div class="fbMeta" id="faithBubbleMeta">Tap to see a short suggestion.</div>
              </div>
              <button class="fbClose" id="faithBubbleClose">√ó</button>
            </div>
            <div class="inputRow">
              <button type="button" class="reactBtn" id="btnVisionPick" aria-label="Attach files" style="margin-bottom:12px;">üì∑</button>
              <input type="file" id="visionInput" multiple accept="image/*,video/*,audio/*,application/pdf,.pdf,.txt,.md,.json,.csv,.doc,.docx,.ppt,.pptx,.xls,.xlsx,application/msword,application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;opacity:0;overflow:hidden;">
              <input class="input" id="userInput" placeholder="Talk to AURA-X Œ©‚Ä¶ (TM = your inputs)" />
              <button class="send" id="sendBtn">Send</button>
            </div>
            <div id="imagePreviewArea">
              <img id="imgPrev" alt="preview">
              <video id="vidPrev" controls muted playsinline style="display:none;max-width:100%;border-radius:14px;"></video>
              <div id="visionHint">Media attached</div>
              <div id="visionList" class="visionList"></div>
              <textarea id="visionNote" class="input" style="margin-top:10px;min-height:54px;resize:vertical" placeholder="Optional note (will be saved into BM with this media)‚Ä¶"></textarea>
              <div style="display:flex;gap:10px;justify-content:flex-end;margin-top:10px;">
                <button class="btn" id="saveVisionToBM" type="button">Save to BM</button>
              </div>
            </div>
            <div class="formula">
              E‚ÇÄ = tanh( R(TM,BM) + I(TM) + I<sub>intel</sub> + I<sub>LLM</sub> ‚àí D + Œª<sub>faith</sub> + Œª<sub>sys</sub> + Œª<sub>trc</sub> )
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Toast bubble -->
  <!-- Sense (Camera + Mic) -->
  <div class="modalOverlay" id="modalSense">
    <div class="modal">
      <div class="modalHeader">
        <div>üëÅÔ∏è Sense (Camera + Mic)<br><small>Capture a moment ‚Üí create a BM prompt stub (local only).</small></div>
        <button class="closeX" data-close="modalSense">√ó</button>
      </div>
      <div class="modalBody" style="background:#fefce8;">
        <div style="opacity:.85;font-size:13px;line-height:1.35;margin-bottom:10px">
          Uses your device camera/microphone only with permission. Nothing is uploaded in this prototype.
          A developer can later plug a Vision / Speech-to-text API to analyse the real content.
        </div>

        <div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:8px">
          <button class="btn btnBlue" id="btnSenseCamera">Camera snapshot</button>
          <button class="btn btnBlue" id="btnSenseMic">Record 10s audio</button>
          <span style="font-size:12px;opacity:.75;align-self:center" id="senseStatus">Idle.</span>
        </div>

        <video id="senseVideo" autoplay playsinline muted
               style="width:100%;max-height:190px;border-radius:14px;border:1px solid rgba(15,23,42,.18);display:none;margin-bottom:8px;background:#000"></video>
        <canvas id="senseCanvas" style="display:none"></canvas>

        <textarea id="senseBMBox"
          style="width:100%;min-height:160px;border-radius:14px;border:1px solid rgba(15,23,42,.18);padding:10px;font-size:13px;line-height:1.4;background:#fff;"
          placeholder="Sense ‚Üí BM prompt stub will appear here‚Ä¶ You can edit before saving."></textarea>

        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;">
          <button class="btn btnGreen" id="btnSaveSenseBM">Save stub to BM</button>
        </div>

        <div style="margin-top:10px;font-size:11px;opacity:.7;line-height:1.35">
          ‚ö† Please respect privacy and local law. Do not record people without consent.  
          This demo does not send media to any server unless you connect your own endpoint in LLM settings.
        </div>
      </div>
    </div>
  </div>

  <div class="toastBubble" id="toastBubble"></div>
  <!-- Dream overlay / screensaver -->
  <div id="dreamOverlay">
    <canvas id="dreamCanvas" aria-hidden="true"></canvas>
    <canvas id="dreamFilmCanvas" aria-hidden="true"></canvas>
    <div id="dreamBmBubble" aria-hidden="true"></div>
    <div class="dreamInner">
      <div class="dreamOrb"></div>
      <div class="dreamText">
        <div class="dreamTitle">AURA-X Œ© is dreaming‚Ä¶</div>
        <div class="dreamSub">Your BM snapshots and recent feelings are drifting in the background. Tap anywhere to wake.</div>
        <div class="dreamMeta" id="dreamMetaText"></div>
      </div>
    </div>
  </div>
  <!-- Faith selection -->
  <div class="modalOverlay" id="modalFaith">
    <div class="modal">
      <div class="modalHeader">
        <div>‚öôÔ∏è AURA-X Œ© options<br><small>Optional faith lens for encouragement lines.</small></div>
        <button class="closeX" data-close="modalFaith">√ó</button>
      </div>
      <div class="modalBody" style="background:#fdf7e5;">
        <div style="opacity:.8;font-size:13px;line-height:1.35;margin-bottom:8px">
          Universal ethics are always active. You can optionally pick one or more faith lenses.
          Nothing is sent to any server.
        </div>
        <div class="chipsWrap" id="faithChips"></div>
      </div>
    </div>
  </div>
  <!-- Faith live bar settings -->
  <div class="modalOverlay" id="modalFaithCfg">
    <div class="modal">
      <div class="modalHeader">
        <div>üîò Faith live bar settings<br><small id="faithCfgFaithTitle">Configure literature & translation.</small></div>
        <button class="closeX" data-close="modalFaithCfg">√ó</button>
      </div>
      <div class="modalBody" style="background:#fefce8;">
        <div style="font-size:13px;margin-bottom:8px;">
          Faith: <span id="faithCfgFaithName" style="font-weight:800;"></span>
        </div>
        <label style="font-size:13px;display:flex;align-items:center;gap:6px;margin-bottom:8px;">
          <input type="checkbox" id="faithCfgEnable" checked />
          <span>Show live religious literature bar (instead of generic line)</span>
        </label>
        <div style="margin-top:4px;">
          <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Translation language</label>
          <select id="faithCfgLang"
            style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:8px 10px;font-size:13px;background:#fff;">
            <option value="auto">Auto (device / location)</option>
            <option value="urdu">Urdu</option>
            <option value="english">English</option>
          </select>
        </div>
        <div style="margin-top:10px;display:flex;gap:8px;justify-content:flex-end;">
          <button class="btn btnBlue" id="faithCfgSave">Save</button>
        </div>
        <div style="font-size:11px;opacity:.65;margin-top:6px;">
          After saving, the small üîò button will disappear. To adjust later, select a different faith once,
          then come back to this faith ‚Äì the button will appear again.
        </div>
      </div>
    </div>
  </div>
  <!-- Faith article -->
  <div class="modalOverlay" id="modalFaithArticle">
    <div class="modal">
      <div class="modalHeader">
        <div>üí≠ Faith reflection<br><small>Story-related suggestion from your selected literature.</small></div>
        <button class="closeX" data-close="modalFaithArticle">√ó</button>
      </div>
      <div class="modalBody" style="background:#fefce8;">
        <div id="faithArticleMeta" style="font-size:12px;opacity:.75;margin-bottom:6px;"></div>
        <div id="faithArticleTitle" style="font-weight:800;margin-bottom:6px;"></div>
        <textarea id="faithArticleText"
          style="width:100%;min-height:160px;border-radius:14px;border:1px solid rgba(15,23,42,.18);padding:10px;font-size:13px;line-height:1.4;background:#fff;"></textarea>
        <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;">
          <button class="btn btnBlue" id="btnCopyFaithArticle">Copy</button>
          <button class="btn btnBlue" id="btnExportFaithArticle">Export</button>
          <button class="btn btnRed" id="btnSkipFaithBM">Skip</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Intelligence -->
  <div class="modalOverlay" id="modalIntel">
    <div class="modal">
      <div class="modalHeader">
        <div>üß† Intelligence<br><small>Stored Q ‚Üí A pairs.</small></div>
        <button class="closeX" data-close="modalIntel">√ó</button>
      </div>
      <div class="modalBody">
        <input id="intelSearch"
          style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none"
          placeholder="Search intelligence..." />
        <div id="intelList" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>
  <!-- Seed + Logic -->
  <div class="modalOverlay" id="modalSeed">
    <div class="modal">
      <div class="modalHeader">
        <div>üå± Feed the seed<br><small>Add LaTeX Q ‚Üí A blocks and optional Logic Pack.</small></div>
        <button class="closeX" data-close="modalSeed">√ó</button>
      </div>
      <div class="modalBody">
        <div style="opacity:.75;font-size:13px;line-height:1.35;margin-bottom:10px">
          Paste a LaTeX block with \item questions and \textbf{A:} answers. You can optionally start each
          answer with [polarity=positive; code=E031; intensity=0.8].
        </div>
        <textarea id="seedBox"
          style="width:100%;min-height:150px;resize:vertical;border-radius:14px;border:2px solid rgba(59,130,246,.25);padding:12px;font-size:14px;outline:none;background:#fff"
          placeholder="Paste LaTeX conversation / logic block here..."></textarea>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-top:10px">
          <div style="font-size:12px;opacity:.7" id="seedHint">Waiting for block‚Ä¶</div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <button class="btn btnBlue" id="btnParseSeed">Parse block</button>
            <button class="btn btnBlue" id="btnSaveSeed">Save to seed</button>
            <button class="btn btnRed" id="btnDiscardSeed">Discard</button>
          </div>
        </div>
        <hr style="margin:14px 0;border:none;border-top:1px dashed rgba(15,23,42,.18);" />
        <div style="font-weight:800;font-size:13px;margin-bottom:6px;">üß© Logic Pack (JSON rules ‚Äì advanced)</div>
        <div style="font-size:12px;opacity:.75;line-height:1.4;margin-bottom:6px;">
          Each time you press <b>Save</b>, a new logic pack is stored with its own number.
          Saved logic packs never auto-delete; they can only be removed manually with double confirmation.
        </div>
        <textarea id="logicBox"
          style="width:100%;min-height:130px;resize:vertical;border-radius:14px;border:2px solid rgba(15,23,42,.18);padding:10px;font-size:13px;outline:none;background:#fff;font-family:ui-monospace,Menlo,Consolas,monospace;"
          placeholder='{
  "cooldown": { "hits": 3, "seconds": 10 },
  "abuseWords": ["stfu","idiot"],
  "faithSoftener": true,
  "ui": { "theme": "golden", "accentColor": "#f97316" }
}'>
        </textarea>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;margin-top:8px;">
          <div style="font-size:12px;opacity:.7" id="logicHint">No logic pack loaded.</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <button class="btn btnBlue" id="btnValidateLogic">Validate</button>
            <button class="btn btnBlue" id="btnSaveLogic">Save</button>
            <button class="btn btnBlue" id="btnCopyLogic">Copy</button>
            <button class="btn btnRed" id="btnDeleteLogic">Delete</button>
          </div>
        </div>
        <div style="margin-top:6px;font-size:11px;opacity:.6;">
          Current serial: <span id="logicSerial">none</span>
        </div>
      </div>
    </div>
  </div>
  <!-- LLM -->
  <div class="modalOverlay" id="modalLLM">
    <div class="modal">
      <div class="modalHeader">
        <div>ü§ñ LLM link<br><small>Offline LLM + optional online helper.</small></div>
        <button class="closeX" data-close="modalLLM">√ó</button>
      </div>
      <div class="modalBody">
        <div style="border-radius:14px;border:1px solid rgba(34,197,94,.25);background:rgba(34,197,94,.12);padding:12px;">
          <div style="font-weight:900;">Offline LLM (WebLLM)</div>
          <div style="font-size:13px;opacity:.8;margin-top:6px;line-height:1.35">
            Loads a small local model in your browser (WebGPU required). On many mobile browsers this may not be supported.
          </div>
          <div style="margin-top:10px;">
            <button class="btn btnGreen" id="btnLoadOffline">Load offline model</button>
          </div>
          <div style="margin-top:8px;font-size:12px;opacity:.75">Status: <span id="offlineStatus">idle</span></div>
          <div style="margin-top:8px;height:10px;border-radius:999px;background:rgba(2,6,23,.12);overflow:hidden;border:1px solid rgba(2,6,23,.08)">
            <div id="offlineBar" style="height:100%;width:0%;background:#22c55e;transition:width .2s ease;"></div>
          </div>
        </div>
        <div style="font-weight:900;margin-top:14px;">Online helper LLM (connects & works)</div>
        <div style="font-size:12px;opacity:.8;margin-top:4px;margin-bottom:4px;">
          Use any compatible API (OpenAI, DeepSeek, xAI, etc.). Nothing is stored on server by AURA-X Œ© itself.
        </div>
        <div style="margin-top:6px;">
          <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">API endpoint</label>
          <input id="apiEndpoint"
            style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
            value="https://api.openai.com/v1/chat/completions" />
        </div>
        <div style="margin-top:10px;">
          <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Model</label>
          <input id="apiModel"
            style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
            value="gpt-4o-mini" />
        </div>
        <div style="margin-top:10px;">
          <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">API key (session only)</label>
          <input id="apiKey"
            style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
            placeholder="sk-..." />
        </div>
        <div style="margin-top:10px;display:flex;justify-content:flex-end;">
          <button class="btn btnBlue" id="btnSaveLLM">Save</button>
        </div>
      </div>
    </div>
  </div>
  <!-- BM Recall -->
  <div class="modalOverlay" id="modalBM">
    <div class="modal">
      <div class="modalHeader">
        <div>üìò Recall from BM<br><small>Only long stories and scenes (photo/video-ready).</small></div>
        <button class="closeX" data-close="modalBM">√ó</button>
      </div>
      <div class="modalBody">
        <div style="font-size:13px;opacity:.75">
          Select a BM prompt. Locked prompts must be unlocked first. Delete needs double confirmation.
        </div>
        <input id="bmSearch"
          style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:8px 10px;font-size:13px;margin:8px 0 4px;outline:none;background:#fff;"
          placeholder="Search BM by text..." />
        <input id="bmDate" type="date"
          style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:8px 10px;font-size:13px;margin:0 0 6px;outline:none;background:#fff;" />
        <div id="bmSelectList"></div>
        <div class="bmCard" id="bmViewer" style="display:none;">
          <div class="bmTop">
            <div>
              <div class="title"><span id="bmLockIcon">üîì</span> <span id="bmTitle">Prompt</span></div>
              <div class="bmSub" id="bmMeta"></div>
            </div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;">
              <button class="btn btnBlue" id="btnLiveBM">Live 12h: off</button>
              <button class="btn btnBlue" id="btnUnlockBM" style="display:none;">Unlock</button>
            </div>
          </div>
          <textarea class="bmText" id="bmTextArea" readonly></textarea>
          <div class="bmActions">
            <button class="btn btnBlue" id="btnCopyPrompt">Copy prompt</button>
            <button class="btn btnBlue" id="btnAutoGen">Generate image</button>
            <button class="btn btnRed" id="btnDeletePrompt">Delete</button>
          </div>
        </div>
        <div class="bmCard" id="bmDreamCard">
          <div class="bmTop">
            <div>
              <div class="title">üåô Dream Mode / screensaver</div>
              <div class="bmSub">
                Choose after how much idle time AURA-X Œ© should enter Dream Mode with your BM snapshots.
              </div>
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;">
              <button class="btn btnBlue" id="btnTestDream">Test now</button>
            </div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;">
            <div style="flex:1;min-width:140px;">
              <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Start after</label>
              <select id="dreamDelaySelect"
                style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:8px 10px;font-size:13px;background:#fff;">
                <option value="30000">30 seconds</option>
                <option value="60000">1 minute</option>
                <option value="120000">2 minutes</option>
                <option value="300000">5 minutes</option>
                <option value="600000">10 minutes</option>
                <option value="1800000">30 minutes</option>
                <option value="3600000">1 hour</option>
                <option value="7200000">2 hours</option>
                <option value="14400000">4 hours</option>
                <option value="28800000">8 hours</option>
              </select>
            </div>
            <div style="flex:0 0 140px;">
              <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Status</label>
              <button class="btn btnGreen" id="btnToggleDream">Enable</button>
            </div>
          </div>
          <div class="bmSub" id="dreamStatusText" style="margin-top:8px;">
            Screensaver is OFF.
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- History -->
  <div class="modalOverlay" id="modalHistory">
    <div class="modal">
      <div class="modalHeader">
        <div>üìú Conversation history<br><small>Recent TM log.</small></div>
        <button class="closeX" data-close="modalHistory">√ó</button>
      </div>
      <div class="modalBody">
        <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:10px;">
          <button class="btn btnBlue" id="btnDeleteRecent">Delete history last 48h</button>
          <button class="btn btnRed" id="btnDeleteAllHist">Delete all history</button>
          <button class="btn btnBlue" id="btnCopyHistory">Copy</button>
        </div>
        <div id="historyBox"></div>
      </div>
    </div>
  </div>
  <!-- Identity -->
  <div class="modalOverlay" id="modalIdentity">
    <div class="modal">
      <div class="modalHeader">
        <div>ü™™ User identity<br><small>Deep profiling for continuity.</small></div>
        <button class="closeX" data-close="modalIdentity">√ó</button>
      </div>
      <div class="modalBody">
        <div style="opacity:.8;font-size:13px;line-height:1.35">
          Stored only on this device. Saved data auto-locks. Delete requires double confirmation.
        </div>
        <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;">
          <button class="btn btnBlue" id="btnEditIdentity">Edit</button>
          <button class="btn btnBlue" id="btnSaveUserIdentity">Save</button>
          <button class="btn btnRed" id="btnDeleteUserIdentity">Delete</button>
        </div>
        <div style="margin-top:14px;font-weight:800;font-size:13px;">Part 1 ‚Äì Basic</div>
        <div style="margin-top:8px;">
          <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Full legal name</label>
          <input id="uName"
            style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
            placeholder="e.g., Alim ul Haq" />
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <div style="flex:1;min-width:140px;">
            <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Preferred name</label>
            <input id="uNick"
              style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
              placeholder="Nickname" />
          </div>
          <div style="flex:1;min-width:140px;">
            <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Place of origin</label>
            <input id="uOrigin"
              style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
              placeholder="Village / town" />
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;flex-wrap:wrap;">
          <div style="flex:1;min-width:140px;">
            <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Current city / country</label>
            <input id="uPlace"
              style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
              placeholder="Timergara, Pakistan" />
          </div>
          <div style="flex:1;min-width:140px;">
            <label style="font-size:12px;opacity:.75;display:block;margin-bottom:4px;">Profession</label>
            <input id="uProfession"
              style="width:100%;border-radius:12px;border:1px solid rgba(15,23,42,.18);padding:10px 12px;font-size:14px;outline:none;background:rgba(255,255,255,.88)"
              placeholder="Entrepreneur, researcher‚Ä¶" />
          </div>
        </div>
        <div style="margin-top:14px;font-weight:800;font-size:13px;">Part 2 ‚Äì Emotional style</div>
        <textarea id="uEmotionalStyle"
          style="width:100%;margin-top:6px;border-radius:14px;border:1px solid rgba(15,23,42,.18);padding:10px;font-size:13px;line-height:1.4;min-height:90px;"
          placeholder="How you react under stress, joy, fear, success‚Ä¶"></textarea>
        <div style="margin-top:14px;font-weight:800;font-size:13px;">Part 3 ‚Äì Relationships & legacy</div>
        <textarea id="uKeyPeople"
          style="width:100%;margin-top:6px;border-radius:14px;border:1px solid rgba(15,23,42,.18);padding:10px;font-size:13px;line-height:1.4;min-height:80px;"
          placeholder="Key people and roles in your life‚Ä¶"></textarea>
        <textarea id="uLegacyRules"
          style="width:100%;margin-top:6px;border-radius:14px;border:1px solid rgba(15,23,42,.18);padding:10px;font-size:13px;line-height:1.4;min-height:80px;"
          placeholder="If one day this system speaks for you, which boundaries and rules must it follow?"></textarea>
      </div>
    </div>
  </div>
  <script>
    window.addEventListener("DOMContentLoaded", () => {
      const KEY_CFG   = "aurax_cfg_v14";
      const KEY_INT   = "aurax_intel_v11";
      const KEY_BM    = "aurax_bm_v11";
      const KEY_HIST  = "aurax_hist_v11";
      const KEY_USER  = "aurax_user_v11";
      const KEY_INTU  = "aurax_intuition_v1";
      const KEY_SENSEG = "aurax_sense_gallery_v1";
      const KEY_LOGIC = "aurax_logic_v12";
      const OFFLINE_MODEL_ID = "Llama-3-8B-Instruct-q4f32_1-MLC";
      const ETHIC_BASE =
        "Universal ethic: avoid actions that grow negative emotions in you or others. " +
        "Move gently toward choices that increase shared positive feeling for everyone.";
      const els = {
        console: document.getElementById("console"),
        btnOptions: document.getElementById("btnOptions"),
        optionsMenu: document.getElementById("optionsMenu"),
        miVoice: document.getElementById("miVoice"),
        miIntel: document.getElementById("miIntel"),
        miLearn: document.getElementById("miLearn"),
        miSeed: document.getElementById("miSeed"),
        miFaith: document.getElementById("miFaith"),
        miIdentity: document.getElementById("miIdentity"),
        miLLM: document.getElementById("miLLM"),
        miBMRecall: document.getElementById("miBMRecall"),
        miHistory: document.getElementById("miHistory"),
        miSense: document.getElementById("miSense"),
        voicePill: document.getElementById("voicePill"),
        learnPill: document.getElementById("learnPill"),
        sensePill: document.getElementById("sensePill"),
        faithLabel: document.getElementById("faithLabel"),
        cE0: document.getElementById("cE0"),
        cTM: document.getElementById("cTM"),
        cBM: document.getElementById("cBM"),
        cCont: document.getElementById("cCont"),
        userInput: document.getElementById("userInput"),
        sendBtn: document.getElementById("sendBtn"),
        btnVisionPick: document.getElementById("btnVisionPick"),
        visionInput: document.getElementById("visionInput"),
        imagePreviewArea: document.getElementById("imagePreviewArea"),
        imgPrev: document.getElementById("imgPrev"),
        vidPrev: document.getElementById("vidPrev"),
        visionHint: document.getElementById("visionHint"),
        visionList: document.getElementById("visionList"),
        visionNote: document.getElementById("visionNote"),
        saveVisionToBM: document.getElementById("saveVisionToBM"),
        faithBubble: document.getElementById("faithBubble"),
        faithBubbleTitle: document.getElementById("faithBubbleTitle"),
        faithBubbleMeta: document.getElementById("faithBubbleMeta"),
        faithBubbleClose: document.getElementById("faithBubbleClose"),
        modalFaith: document.getElementById("modalFaith"),
        faithChips: document.getElementById("faithChips"),
        modalFaithArticle: document.getElementById("modalFaithArticle"),
        faithArticleMeta: document.getElementById("faithArticleMeta"),
        faithArticleTitle: document.getElementById("faithArticleTitle"),
        faithArticleText: document.getElementById("faithArticleText"),
        btnCopyFaithArticle: document.getElementById("btnCopyFaithArticle"),
        btnExportFaithArticle: document.getElementById("btnExportFaithArticle"),
        btnSkipFaithBM: document.getElementById("btnSkipFaithBM"),
        modalIntel: document.getElementById("modalIntel"),
        intelSearch: document.getElementById("intelSearch"),
        intelList: document.getElementById("intelList"),
        modalSeed: document.getElementById("modalSeed"),
        seedBox: document.getElementById("seedBox"),
        seedHint: document.getElementById("seedHint"),
        btnParseSeed: document.getElementById("btnParseSeed"),
        btnSaveSeed: document.getElementById("btnSaveSeed"),
        btnDiscardSeed: document.getElementById("btnDiscardSeed"),
        logicBox: document.getElementById("logicBox"),
        logicHint: document.getElementById("logicHint"),
        logicSerial: document.getElementById("logicSerial"),
        btnValidateLogic: document.getElementById("btnValidateLogic"),
        btnSaveLogic: document.getElementById("btnSaveLogic"),
        btnCopyLogic: document.getElementById("btnCopyLogic"),
        btnDeleteLogic: document.getElementById("btnDeleteLogic"),
        modalLLM: document.getElementById("modalLLM"),
        btnLoadOffline: document.getElementById("btnLoadOffline"),
        offlineStatus: document.getElementById("offlineStatus"),
        offlineBar: document.getElementById("offlineBar"),
        apiEndpoint: document.getElementById("apiEndpoint"),
        apiModel: document.getElementById("apiModel"),
        apiKey: document.getElementById("apiKey"),
        btnSaveLLM: document.getElementById("btnSaveLLM"),
        modalBM: document.getElementById("modalBM"),
        bmSearch: document.getElementById("bmSearch"),
        bmDate: document.getElementById("bmDate"),
        bmSelectList: document.getElementById("bmSelectList"),
        bmViewer: document.getElementById("bmViewer"),
        bmLockIcon: document.getElementById("bmLockIcon"),
        bmTitle: document.getElementById("bmTitle"),
        bmMeta: document.getElementById("bmMeta"),
        bmTextArea: document.getElementById("bmTextArea"),
        btnLiveBM: document.getElementById("btnLiveBM"),
        btnUnlockBM: document.getElementById("btnUnlockBM"),
        btnCopyPrompt: document.getElementById("btnCopyPrompt"),
        btnAutoGen: document.getElementById("btnAutoGen"),
        btnDeletePrompt: document.getElementById("btnDeletePrompt"),
        modalHistory: document.getElementById("modalHistory"),
        modalSense: document.getElementById("modalSense"),
        btnSenseCamera: document.getElementById("btnSenseCamera"),
        btnSenseMic: document.getElementById("btnSenseMic"),
        senseVideo: document.getElementById("senseVideo"),
        senseCanvas: document.getElementById("senseCanvas"),
        senseStatus: document.getElementById("senseStatus"),
        senseBMBox: document.getElementById("senseBMBox"),
        btnSaveSenseBM: document.getElementById("btnSaveSenseBM"),
        btnDeleteRecent: document.getElementById("btnDeleteRecent"),
        btnDeleteAllHist: document.getElementById("btnDeleteAllHist"),
        btnCopyHistory: document.getElementById("btnCopyHistory"),
        historyBox: document.getElementById("historyBox"),
        modalIdentity: document.getElementById("modalIdentity"),
        btnEditIdentity: document.getElementById("btnEditIdentity"),
        btnSaveUserIdentity: document.getElementById("btnSaveUserIdentity"),
        btnDeleteUserIdentity: document.getElementById("btnDeleteUserIdentity"),
        uName: document.getElementById("uName"),
        uNick: document.getElementById("uNick"),
        uOrigin: document.getElementById("uOrigin"),
        uPlace: document.getElementById("uPlace"),
        uProfession: document.getElementById("uProfession"),
        uEmotionalStyle: document.getElementById("uEmotionalStyle"),
        uKeyPeople: document.getElementById("uKeyPeople"),
        uLegacyRules: document.getElementById("uLegacyRules"),
        btnLikeLast: document.getElementById("btnLikeLast"),
        btnDislikeLast: document.getElementById("btnDislikeLast"),
        btnSpeakLast: document.getElementById("btnSpeakLast"),
        btnShareLast: document.getElementById("btnShareLast"),
        toastBubble: document.getElementById("toastBubble"),
        dreamOverlay: document.getElementById("dreamOverlay"),
        dreamCanvas: document.getElementById("dreamCanvas"),
        dreamFilmCanvas: document.getElementById("dreamFilmCanvas"),
        dreamBmBubble: document.getElementById("dreamBmBubble"),
        dreamMetaText: document.getElementById("dreamMetaText"),
        dreamDelaySelect: document.getElementById("dreamDelaySelect"),
        btnToggleDream: document.getElementById("btnToggleDream"),
        btnTestDream: document.getElementById("btnTestDream"),
        dreamStatusText: document.getElementById("dreamStatusText"),
        ethicBox: document.getElementById("ethicBox"),
        ethicMain: document.getElementById("ethicMain"),
        ethicMeta: document.getElementById("ethicMeta"),
        faithCfgBtn: document.getElementById("faithCfgBtn"),
        modalFaithCfg: document.getElementById("modalFaithCfg"),
        faithCfgFaithTitle: document.getElementById("faithCfgFaithTitle"),
        faithCfgFaithName: document.getElementById("faithCfgFaithName"),
        faithCfgEnable: document.getElementById("faithCfgEnable"),
        faithCfgLang: document.getElementById("faithCfgLang"),
        faithCfgSave: document.getElementById("faithCfgSave")
      };
      const FAITH_OPTIONS = [
        { id:"none",         label:"None" },
        { id:"islam",        label:"Islam" },
        { id:"christianity", label:"Christianity" },
        { id:"hinduism",     label:"Hinduism" },
        { id:"buddhism",     label:"Buddhism" },
        { id:"sikhism",      label:"Sikhism" },
        { id:"judaism",      label:"Judaism" },
        { id:"atheism",      label:"Atheism / Humanism" },
        { id:"mixed",        label:"Other / Mixed" },
        { id:"indigenous",   label:"Indigenous / Traditional" },
        { id:"eastern",      label:"Eastern / Chinese" }
      ];
      /* Short, ethics-style religious lines + translations */
      const FAITH_LITERATURE = {
        islam: {
          base: {
            original: "Ÿ±ŸÑŸíŸÖŸèÿ≥ŸíŸÑŸêŸÖŸè ŸÖŸéŸÜŸí ÿ≥ŸéŸÑŸêŸÖŸé Ÿ±ŸÑŸíŸÖŸèÿ≥ŸíŸÑŸêŸÖŸèŸàŸÜŸé ŸÖŸêŸÜ ŸÑŸêÿ≥ŸéÿßŸÜŸêŸáŸê ŸàŸéŸäŸéÿØŸêŸáŸê",
            translations: {
              urdu:   "ÿ≥⁄Üÿß ŸÖÿ≥ŸÑŸÖÿßŸÜ Ÿà€Å €Å€í ÿ¨ÿ≥ ⁄©€å ÿ≤ÿ®ÿßŸÜ ÿßŸàÿ± €Åÿßÿ™⁄æ ÿ≥€í ÿØŸàÿ≥ÿ±€í ŸÖÿ≠ŸÅŸàÿ∏ ÿ±€Å€å⁄∫€î",
              english:"A true Muslim is the one from whose tongue and hand other people remain safe."
            }
          }
        },
        christianity: {
          base: {
            original: "‚ÄúLove your neighbour as yourself.‚Äù",
            translations: {
              urdu:   "ÿßŸæŸÜ€í Ÿæ⁄ëŸàÿ≥€å ÿ≥€í Ÿà€åÿ≥€í €Å€å ŸÖÿ≠ÿ®ÿ™ ⁄©ÿ±Ÿà ÿ¨€åÿ≥€í ÿ™ŸÖ ÿßŸæŸÜ€í ÿ¢Ÿæ ÿ≥€í ⁄©ÿ±ÿ™€í €ÅŸà€î",
              english:"Love your neighbour as you love yourself."
            }
          }
        },
        hinduism: {
          base: {
            original: "‡§Ö‡§π‡§ø‡§Ç‡§∏‡§æ ‡§™‡§∞‡§Æ‡•ã ‡§ß‡§∞‡•ç‡§Æ‡§É",
            translations: {
              urdu:   "ÿß€ÅŸÜÿ≥ÿß €åÿπŸÜ€å ⁄©ÿ≥€å ÿ¨ÿßŸÜÿØÿßÿ± ⁄©Ÿà ÿ™⁄©ŸÑ€åŸÅ ŸÜ€Å ÿØ€åŸÜÿßÿå ÿ≥ÿ® ÿ≥€í ÿ®⁄ëÿß ÿßÿµŸàŸÑ €Å€í€î",
              english:"Ahimsa ‚Äì not harming any living being ‚Äì is a highest principle."
            }
          }
        },
        buddhism: {
          base: {
            original: "Hatred is never ended by hatred, but by compassion and understanding.",
            translations: {
              urdu:   "ŸÜŸÅÿ±ÿ™ ⁄©ÿ®⁄æ€å ŸÜŸÅÿ±ÿ™ ÿ≥€í ÿÆÿ™ŸÖ ŸÜ€Å€å⁄∫ €ÅŸàÿ™€åÿå ÿ®ŸÑ⁄©€Å ÿµÿ±ŸÅ ÿ±ÿ≠ŸÖ ÿßŸàÿ± ÿ≥ŸÖÿ¨⁄æ ÿ≥€í ÿÆÿ™ŸÖ €ÅŸàÿ™€å €Å€í€î",
              english:"Hatred is not ended by hatred, but by compassion and understanding."
            }
          }
        },
        sikhism: {
          base: {
            original: "‡®∏‡®∞‡®¨‡©±‡®§ ‡®¶‡®æ ‡®≠‡®≤‡®æ ‚Äì seek the welfare of all.",
            translations: {
              urdu:   "ÿ≥ÿ±ÿ®ÿ™ ÿØÿß ÿ®⁄æŸÑÿß: ÿ≥ÿ® ⁄©€å ÿ®€Åÿ™ÿ±€å ÿßŸàÿ± ÿ®⁄æŸÑÿßÿ¶€å ⁄©ÿß ÿ≥Ÿà⁄ÜŸà€î",
              english:"Sarbat da bhala: seek the well-being of everyone."
            }
          }
        },
        judaism: {
          base: {
            original: "What is hateful to you, do not do to others.",
            translations: {
              urdu:   "ÿ¨Ÿà ÿ®ÿßÿ™ ÿ™ŸÖ€Å€å⁄∫ ÿßŸæŸÜ€í ŸÑ€å€í ÿ®ÿ±€å ŸÑ⁄Ø€íÿå Ÿà€Å ÿØŸàÿ≥ÿ±Ÿà⁄∫ ⁄©€í ÿ≥ÿßÿ™⁄æ ŸÖÿ™ ⁄©ÿ±Ÿà€î",
              english:"What is hateful to you, do not do to others."
            }
          }
        },
        atheism: {
          base: {
            original: "Do no unnecessary harm; leave people freer and kinder than you found them.",
            translations: {
              urdu:   "ÿ®ŸÑÿßŸàÿ¨€Å ⁄©ÿ≥€å ⁄©Ÿà ŸÜŸÇÿµÿßŸÜ ŸÖÿ™ Ÿæ€ÅŸÜ⁄Üÿßÿ§ÿå ÿßŸàÿ± ŸÑŸà⁄ØŸà⁄∫ ⁄©Ÿà Ÿæ€ÅŸÑ€í ÿ≥€í ÿ≤€åÿßÿØ€Å ÿ¢ÿ≤ÿßÿØ ÿßŸàÿ± ŸÖ€Åÿ±ÿ®ÿßŸÜ ⁄Ü⁄æŸà⁄ëŸà€î",
              english:"Cause no needless harm and try to leave people freer and kinder than you found them."
            }
          }
        }
      };
      const ETHIC_LIBRARY = {
        general: {
          general: ETHIC_BASE,
          hardship: "Even in difficult stories, keep one ethic: do not add more hurt to hearts. Move slowly toward responses that reduce suffering and open space for calm.",
          relationships: "When the topic is about relationships, speak in a way that keeps dignity on both sides. Protect trust, avoid humiliation, and move toward repair when possible.",
          health: "For health and illness topics, let ethics mean gentleness: be kind to your own limits and respectful to others‚Äô pain while choosing steps that protect life.",
          work: "For work, money and projects, keep ethics above short-term gain. Prefer choices that are fair, transparent and do not crush anyone‚Äôs future.",
          gratitude: "When the story carries blessings, let ethics mean gratitude in action: share good, avoid arrogance, and remember how quickly conditions can change.",
          faith: "When faith enters the story, hold your views with sincerity and humility. Avoid mocking, invite reflection, and keep room for difference without hatred."
        },
        islam: {
          general: "From an Islamic lens: the best ethic is to avoid zulm (harm, injustice) in any form and to choose ihsan (excellence) where you can.",
          hardship: "From an Islamic lens: tests can raise a person in rank. Do not let pain push you into zulm. Choose sabr, du'a and gentle speech even when the heart is heavy.",
          relationships: "From an Islamic lens: ties of kinship and trust are amanah. Guard people‚Äôs honour, control the tongue, and seek sulh (reconciliation) where possible.",
          health: "From an Islamic lens: your body is an amanah. Seek treatment, avoid despair, and do not choose paths that casually risk your life or others‚Äô.",
          work: "From an Islamic lens: rizq is from Allah, but justice is your duty. Avoid cheating, riba and exploitation; aim for halal income with clean conscience.",
          gratitude: "From an Islamic lens: when blessings appear, say Alhamdulillah with the tongue and show shukr by sharing and avoiding arrogance.",
          faith: "From an Islamic lens: discuss faith with adab. Avoid ridicule, protect sacred things from mockery, and invite towards truth with wisdom and beautiful reminder."
        }
      };
      const defaultDeviceLang = (navigator.language || "").toLowerCase().startsWith("ur") ? "urdu" : "english";
      let state = {
        voiceOn: false,
        learningOn: true,
        faithSelection: [],
        faithLiveOptions: {},   // { islam: {enabled:true, lang:"urdu"} , ... }
        intelligence: [],
        seedPairs: [],
        bmPrompts: [],
        history: [],
        userIdentity: null,
        apiConfig: { endpoint: "", model: "", key: "" },
        offlineEngine: null,
        offlineLoading: false,
        offlineReady: false,
        lastAnswerSource: null,
        lastUserQ: null,
        lastAuraA: null,
        correcting: false,
        metrics: { TM:0, BM:0, C:0.85, E0:0 },
        parsedSeed: [],
        editingIntelId: null,
        lastStoryInput: null,
        lastStoryBMId: null,
        faithBubbleTimer: null,
        currentFaithArticle: null,
        logicPacks: [],
        logicActiveIndex: null,
        abuseCount: 0,
        cooldownUntil: 0,
        mode: "adult",
        logicFaithSoftener: true,
        toastTimer: null,
        selectedBMId: null,
        dreamEnabled: false,
        dreamDelayMs: 600000,
        dreamTimerId: null,
        lastActivityTs: Date.now(),
        ethic: { topic:"general", lens:"none", lastUpdate:0, messageCount:0 },
        currentFaith: "none",
        faithFlightPending: false,
        faithFlightDone: false,
        currentFaithForCfg: null,
        sense: { stream:null, mediaRecorder:null, chunks:[], busy:false },
        senseGallery: [],
        pendingVision: null,
        dreamCfg: { intensityThreshold: 0.72, glimpseEveryMs: 14000, glimpseHoldMs: 5200, textureEveryMs: 12000 },
        dreamFX: { running:false, rafId:0, t0:0, lastTexture:0, lastGlimpse:0, particles:[], textures:[], filmSeed:0, filmHoldUntil:0 },
        intuition: { enabled:false, lastRun:0, captureIntervalMin:30, cameraEnabled:true, micEnabled:false, lastCapture:0, pocketDarkFrames:0 },
        intuitionLog: []
      };
      function safeLoadJSON(key, fallback){
        try{
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        }catch{ return fallback; }
      }
      function logLine(roleOrText, maybeText){
        let role = "";
        let text;
        if (typeof maybeText === "undefined"){ text = roleOrText; }
        else { role = roleOrText || ""; text = maybeText; }
        const div = document.createElement("div");
        div.className = "line" + (role ? " " + role : "");
        div.textContent = text;
        els.console.appendChild(div);
        els.console.scrollTop = els.console.scrollHeight;
        if(role === "user" || role === "aura"){
          addHistory(role, text);
        }
      }
      function scoreTM(t){
        const len = Math.min((t||"").length,600);
        return Number(Math.tanh(len/200).toFixed(2));
      }
      function recomputeBMMetric(){
        const count = state.bmPrompts.length || 0;
        state.metrics.BM = Number(Math.tanh(count/10).toFixed(2));
      }
      function applyEmotionalTheme(){
        const e0 = state.metrics.E0;
        const root = document.documentElement;
        let baseColor = "#0ea5e9";
        let bgOverlay = "transparent";
        if(e0 > 0.3){
          const intensity = Math.min((e0 - 0.3) * 2, 1);
          baseColor = "#fbbf24";
          bgOverlay = `rgba(251,191,36,${0.08 + 0.12*intensity})`;
        } else if(e0 < -0.3){
          const intensity = Math.min((Math.abs(e0) - 0.3) * 2, 1);
          baseColor = "#64748b";
          bgOverlay = `rgba(15,23,42,${0.25 + 0.25*intensity})`;
        }
        root.style.setProperty('--accent-color', baseColor);
        document.body.style.backgroundImage =
          `linear-gradient(${bgOverlay}, ${bgOverlay}),
           radial-gradient(circle at 20% 0%, #1e293b 0, transparent 45%),
           radial-gradient(circle at 80% 0, ${baseColor} 0, transparent 40%),
           linear-gradient(145deg,#020617 0,#020617 40%,#020617 100%)`;
      }
      function recomputeE0(intelBoost, llmBoost){
        const TM = state.metrics.TM;
        const BM = state.metrics.BM;
        const R = TM * BM;
        const I_tm = 0.3 * TM;
        const D = 0.1;
        const lambdaFaith = state.faithSelection.length ? 0.15 : 0;
        const lambdaSys   = 0.05;
        const lambdaTrc   = 0.05;
        const raw = R + I_tm + intelBoost + llmBoost - D + lambdaFaith + lambdaSys + lambdaTrc;
        state.metrics.E0 = Number(Math.tanh(raw).toFixed(3));
        applyEmotionalTheme();
      }
      function updateCapsule(){
        els.cTM.textContent = state.metrics.TM.toFixed(2);
        els.cBM.textContent = state.metrics.BM.toFixed(2);
        els.cCont.textContent = state.metrics.C.toFixed(3);
        els.cE0.textContent = state.metrics.E0.toFixed(3);
      }
      function showToast(msg){
        if(!els.toastBubble) return;
        els.toastBubble.textContent = msg;
        els.toastBubble.classList.add("show");
        if(state.toastTimer) clearTimeout(state.toastTimer);
        state.toastTimer = setTimeout(()=>{
          els.toastBubble.classList.remove("show");
        },1600);
      }
      /* Dream mode */
      function updateDreamUI(){
        if(!els.dreamDelaySelect || !els.btnToggleDream || !els.dreamStatusText) return;
        if(state.dreamEnabled){
          els.btnToggleDream.textContent = "Disable";
          els.btnToggleDream.className = "btn btnRed";
        }else{
          els.btnToggleDream.textContent = "Enable";
          els.btnToggleDream.className = "btn btnGreen";
        }
        const current = state.dreamDelayMs;
        let bestVal = els.dreamDelaySelect.options.length ? els.dreamDelaySelect.options[0].value : String(current);
        let bestDiff = Infinity;
        Array.from(els.dreamDelaySelect.options).forEach(opt=>{
          const v = parseInt(opt.value,10);
          const diff = Math.abs(v-current);
          if(diff<bestDiff){bestDiff=diff;bestVal=opt.value;}
        });
        els.dreamDelaySelect.value = bestVal;
        const ms = state.dreamDelayMs;
        let label;
        if(ms < 60000){
          label = Math.round(ms/1000) + " seconds";
        }else{
          const mins = ms/60000;
          if(mins >= 60){
            const hrs = mins/60;
            label = hrs.toFixed(1).replace(/\.0$/,"") + " hours";
          }else{
            label = mins + " minutes";
          }
        }
        els.dreamStatusText.textContent = state.dreamEnabled
          ? "Screensaver is ON ¬∑ starts after " + label + " of no activity."
          : "Screensaver is OFF.";
      }
      function showDreamOverlay(){
        if(!els.dreamOverlay) return;
        startDreamEngine();
        const bmCount = state.bmPrompts.length || 0;
        if(els.dreamMetaText){
          els.dreamMetaText.textContent = (bmCount
            ? "Dreaming across " + bmCount + " BM snapshot" + (bmCount>1?"s":"") + "‚Ä¶"
            : "Dreaming gently with recent TM feelings (no BM snapshots stored yet).")
            + "  ¬∑  Tap anywhere to return";
        }
        // Intro UI (short) ‚Üí then hide the basic overlay so Dream visuals stay clean.
        els.dreamOverlay.classList.add("show");
        els.dreamOverlay.classList.add("intro");
        els.dreamOverlay.classList.remove("deep");
        if(state.dreamFX.introTimerId) clearTimeout(state.dreamFX.introTimerId);
        state.dreamFX.introTimerId = setTimeout(()=>{
          if(!els.dreamOverlay.classList.contains("show")) return;
          els.dreamOverlay.classList.add("deep");
          els.dreamOverlay.classList.remove("intro");
        }, 950);
      }
      function hideDreamOverlay(){
        if(!els.dreamOverlay) return;
        stopDreamEngine();
        els.dreamOverlay.classList.remove("show","intro","deep");
        if(state.dreamFX.introTimerId) clearTimeout(state.dreamFX.introTimerId);
        state.dreamFX.introTimerId = 0;
        scheduleDreamTimer();
      }
      function scheduleDreamTimer(){
        state.lastActivityTs = Date.now();
        if(state.dreamTimerId){ clearTimeout(state.dreamTimerId); state.dreamTimerId = null; }
        if(!state.dreamEnabled) return;
        const delay = Math.min(Math.max(state.dreamDelayMs,30000), 28800000);
        state.dreamDelayMs = delay;
        state.dreamTimerId = setTimeout(()=>{ showDreamOverlay(); }, delay);
      }


      /* =========================================================
         Dreaming Screensaver v4.9+ (advanced, no UI disturbance)
         - Procedural cloud animation on canvas
         - Occasional "BM film" glimpses when intensity threshold is met
         - Optional blending of Sense thumbnails (if captured) into clouds
         ========================================================= */

      function computePromptIntensity(text){
        const t = String(text||"");
        // If intensity is explicitly embedded, respect it.
        const m = t.match(/intensity\s*[:=]\s*([0-9]*\.?[0-9]+)/i);
        if(m){
          const v = Number(m[1]);
          if(!Number.isNaN(v)){
            return Math.max(0, Math.min(1, v > 1 ? v/100 : v));
          }
        }
        const len = Math.min(t.length, 1200);
        const ex = (t.match(/[!ÔºÅ]/g)||[]).length;
        const emo = (t.match(/üòä|üò¢|üò≠|üò°|‚ù§Ô∏è|üíî|üî•|‚ö°|‚ú®|üôè|üò±|üòç|üòû/g)||[]).length;
        const caps = (t.match(/\b[A-Z]{3,}\b/g)||[]).length;
        const weightWords = (t.match(/\b(love|fear|pain|loss|hope|dream|death|life|faith|truth|anger|joy|sad|happy|panic)\b/ig)||[]).length;
        let score = Math.tanh(len/260);
        score += Math.min(0.18, ex*0.03);
        score += Math.min(0.18, emo*0.05);
        score += Math.min(0.10, caps*0.03);
        score += Math.min(0.18, weightWords*0.04);
        return Math.max(0, Math.min(1, Number(score.toFixed(3))));
      }

      function seedRand(seed){
        // Deterministic-ish RNG for film movement.
        let x = (seed >>> 0) || 123456789;
        return function(){
          x ^= x << 13; x >>>= 0;
          x ^= x >> 17; x >>>= 0;
          x ^= x << 5;  x >>>= 0;
          return (x >>> 0) / 4294967296;
        };
      }

      function initDreamCanvasSize(){
        if(!els.dreamCanvas || !els.dreamFilmCanvas) return;
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const w = Math.floor(window.innerWidth * dpr);
        const h = Math.floor(window.innerHeight * dpr);
        els.dreamCanvas.width = w;
        els.dreamCanvas.height = h;
        els.dreamCanvas.dataset.dpr = String(dpr);

        // Film canvas: keep 16:9 in the middle
        const fw = Math.floor(Math.min(w*0.86, 960*dpr));
        const fh = Math.floor(fw * 9/16);
        els.dreamFilmCanvas.width = fw;
        els.dreamFilmCanvas.height = fh;
      }

      function initDreamParticles(){
        const canvas = els.dreamCanvas;
        if(!canvas) return;
        const w = canvas.width;
        const h = canvas.height;
        const rand = seedRand(Date.now());
        const n = Math.max(32, Math.floor((w*h) / 520000)); // scales with screen
        state.dreamFX.particles = [];
        for(let i=0;i<n;i++){
          state.dreamFX.particles.push({
            x: rand()*w,
            y: rand()*h,
            r: (rand()*120 + 80),
            a: rand()*0.10 + 0.05,
            vx: (rand()*0.24 + 0.05),
            vy: (rand()*0.10 - 0.05),
            wob: rand()*Math.PI*2,
            wobSp: rand()*0.0022 + 0.001,
            hueOff: rand()*120 - 30,     // shift across pink/cyan/violet
            sat: 62 + rand()*18,
            lum: 58 + rand()*12
          });
        }
        // Tiny sparkles (fantasy)
        const sN = Math.max(40, Math.floor((w*h)/180000));
        state.dreamFX.sparkles = [];
        for(let i=0;i<sN;i++){
          state.dreamFX.sparkles.push({
            x: rand()*w, y: rand()*h,
            r: rand()*1.6 + 0.6,
            tw: rand()*Math.PI*2,
            sp: rand()*0.02 + 0.01,
            vx: (rand()*0.35 + 0.08),
            vy: (rand()*0.18 - 0.09),
            hue: rand()*360
          });
        }
      }

      function drawDreamClouds(now){
        const canvas = els.dreamCanvas;
        if(!canvas) return;
        const ctx = canvas.getContext("2d");
        const w = canvas.width, h = canvas.height;
        const t = now / 1000;

        // Background gradient that slowly shifts hue (fantasy theme)
        ctx.clearRect(0,0,w,h);
        ctx.globalCompositeOperation = "source-over";
        const baseHue = (t*6) % 360;
        const bg = ctx.createLinearGradient(0,0,0,h);
        bg.addColorStop(0, `hsla(${(baseHue+210)%360}, 75%, 10%, 0.96)`);
        bg.addColorStop(0.55, `hsla(${(baseHue+260)%360}, 75%, 8%, 0.96)`);
        bg.addColorStop(1, `hsla(${(baseHue+300)%360}, 75%, 6%, 0.98)`);
        ctx.fillStyle = bg;
        ctx.fillRect(0,0,w,h);

        // Soft vignette
        const vg = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.18, w/2,h/2, Math.max(w,h)*0.75);
        vg.addColorStop(0, "rgba(0,0,0,0)");
        vg.addColorStop(1, "rgba(2,6,23,0.55)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,w,h);

        // Aurora ribbons (glowing, multi-color)
        ctx.globalCompositeOperation = "screen";
        ctx.filter = "blur(14px)";
        for(let k=0;k<3;k++){
          const yMid = h*(0.28 + k*0.14) + Math.sin(t*0.45 + k)*h*0.03;
          const amp = h*(0.03 + k*0.01);
          const g = ctx.createLinearGradient(0,yMid-amp, w,yMid+amp);
          g.addColorStop(0, `hsla(${(baseHue+300+k*40)%360}, 88%, 66%, 0.08)`);
          g.addColorStop(0.5, `hsla(${(baseHue+180+k*30)%360}, 92%, 64%, 0.12)`);
          g.addColorStop(1, `hsla(${(baseHue+40+k*30)%360}, 90%, 62%, 0.08)`);
          ctx.strokeStyle = g;
          ctx.lineWidth = h*(0.08 - k*0.015);
          ctx.beginPath();
          for(let x=0;x<=w;x+=w/6){
            const phase = (x/w)*Math.PI*2;
            const yy = yMid + Math.sin(phase*1.1 + t*0.7 + k)*amp + Math.cos(phase*0.8 - t*0.45)*amp*0.6;
            if(x===0) ctx.moveTo(x,yy);
            else ctx.quadraticCurveTo(x-w/12, yy, x, yy);
          }
          ctx.stroke();
        }
        ctx.filter = "none";

        // Dream clouds (glowing blobs) - richer palette
        ctx.globalCompositeOperation = "screen";
        ctx.filter = "blur(28px)";
        for(const p of state.dreamFX.particles){
          p.wob += p.wobSp;
          p.x += p.vx;
          p.y += p.vy + Math.sin(p.wob)*0.06;

          if(p.x - p.r > w) p.x = -p.r;
          if(p.y - p.r > h) p.y = -p.r;
          if(p.y + p.r < 0) p.y = h + p.r;

          const hue = (baseHue + p.hueOff + Math.sin(t*0.35 + p.wob)*22) % 360;
          const alpha = p.a * (0.85 + 0.25*Math.sin(t*0.6 + p.wob));
          const grd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.r);
          grd.addColorStop(0, `hsla(${hue}, ${p.sat}%, ${p.lum+10}%, ${alpha})`);
          grd.addColorStop(0.35, `hsla(${(hue+40)%360}, ${p.sat+8}%, ${p.lum}%, ${alpha*0.75})`);
          grd.addColorStop(0.7, `hsla(${(hue+120)%360}, ${p.sat}%, ${p.lum-8}%, ${alpha*0.45})`);
          grd.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = grd;
          ctx.beginPath();
          ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
          ctx.fill();
        }
        ctx.filter = "none";
        ctx.globalCompositeOperation = "source-over";

        // Blend a Sense thumbnail texture occasionally (if present) into clouds (no hard rectangle)
        if(state.dreamFX.textures && state.dreamFX.textures.length){
          if(!state.dreamFX.lastTexture || (now - state.dreamFX.lastTexture) > state.dreamCfg.textureEveryMs){
            state.dreamFX.lastTexture = now;
            const tex = state.dreamFX.textures[Math.floor(Math.random()*state.dreamFX.textures.length)];
            state.dreamFX.activeTexture = tex;
            state.dreamFX.activeTextureUntil = now + 9500;
          }
          const tex = state.dreamFX.activeTexture;
          if(tex && state.dreamFX.activeTextureUntil > now){
            try{
              const img = tex.img;
              if(img && img.complete){
                ctx.globalCompositeOperation = "screen";
                ctx.globalAlpha = 0.14;
                ctx.filter = "blur(24px) saturate(1.25) contrast(1.05)";
                const scale = 1.65 + Math.sin(now/6800)*0.10;
                const iw = img.width*scale, ih = img.height*scale;
                const x = (w-iw)/2 + Math.sin(now/4100)*w*0.05;
                const y = (h-ih)/2 + Math.cos(now/4600)*h*0.05;
                ctx.drawImage(img, x, y, iw, ih);
                ctx.filter = "none";
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
              }
            }catch(e){}
          }
        }

        // Sparkles on top
        if(state.dreamFX.sparkles && state.dreamFX.sparkles.length){
          ctx.globalCompositeOperation = "lighter";
          for(const s of state.dreamFX.sparkles){
            s.tw += s.sp;
            s.x += s.vx;
            s.y += s.vy + Math.sin(s.tw)*0.10;
            if(s.x > w+10) s.x = -10;
            if(s.y > h+10) s.y = -10;
            if(s.y < -10) s.y = h+10;
            const a = 0.20 + 0.30*(0.5+0.5*Math.sin(s.tw*2.3));
            ctx.fillStyle = `hsla(${(s.hue+baseHue)%360}, 90%, 70%, ${a})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r*(0.8+0.6*Math.sin(s.tw)), 0, Math.PI*2);
            ctx.fill();
          }
          ctx.globalCompositeOperation = "source-over";
        }
      }

      function renderBmFilm(text, now){
        const c = els.dreamFilmCanvas;
        if(!c) return;
        const ctx = c.getContext("2d");
        const w = c.width, h = c.height;

        // Film seed for motion
        const r = seedRand(state.dreamFX.filmSeed || (Date.now() & 0xffffffff));
        const t = now/1000;

        // Background haze
        ctx.clearRect(0,0,w,h);
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(255,255,255,0.02)";
        ctx.fillRect(0,0,w,h);

        // Motion streaks
        ctx.globalCompositeOperation = "screen";
        ctx.filter = "blur(10px)";
        for(let i=0;i<22;i++){
          const x = (r()*w + (Math.sin(t*0.9+i)*w*0.08)) % w;
          const y = (r()*h + (Math.cos(t*1.1+i)*h*0.08)) % h;
          const rw = r()*w*0.55 + w*0.20;
          const rh = r()*h*0.25 + h*0.10;
          const a = 0.04 + r()*0.05;
          const g = ctx.createRadialGradient(x,y,0,x,y,Math.max(rw,rh));
          g.addColorStop(0, `rgba(125,211,252,${a})`);
          g.addColorStop(0.55, `rgba(14,165,233,${a*0.9})`);
          g.addColorStop(1, "rgba(2,6,23,0)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.ellipse(x,y,rw,rh, r()*Math.PI, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.filter = "none";

        // Caption text (center)
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "rgba(224,242,254,0.92)";
        ctx.font = "900 24px system-ui, -apple-system, Segoe UI, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Wrap the text (simple)
        const maxW = w*0.78;
        const words = String(text||"").split(/\s+/).slice(0, 44);
        const lines = [];
        let line = "";
        for(const word of words){
          const test = (line?line+" ":"") + word;
          if(ctx.measureText(test).width > maxW){
            if(line) lines.push(line);
            line = word;
          }else{
            line = test;
          }
          if(lines.length >= 3) break;
        }
        if(line && lines.length < 4) lines.push(line);
        const startY = h*0.52 - (lines.length-1)*18;
        // subtle background plate
        ctx.fillStyle = "rgba(2,6,23,0.35)";
        ctx.strokeStyle = "rgba(148,163,184,0.28)";
        const padX = 26, padY = 18;
        const plateH = lines.length*34 + padY;
        ctx.beginPath();
        roundRect(ctx, w*0.12, startY - plateH/2, w*0.76, plateH, 24);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "rgba(224,242,254,0.94)";
        ctx.shadowColor = "rgba(125,211,252,0.25)";
        ctx.shadowBlur = 20;
        let y = startY;
        for(const ln of lines){
          ctx.fillText(ln, w/2, y);
          y += 34;
        }
        ctx.shadowBlur = 0;

        // vignette
        const vg = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.20, w/2,h/2, Math.max(w,h)*0.65);
        vg.addColorStop(0, "rgba(0,0,0,0)");
        vg.addColorStop(1, "rgba(2,6,23,0.55)");
        ctx.fillStyle = vg;
        ctx.fillRect(0,0,w,h);
      }

      function roundRect(ctx, x, y, w, h, r){
        const rr = Math.min(r, w/2, h/2);
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }

      function pickBmGlimpse(){
        const threshold = state.dreamCfg.intensityThreshold;
        const list = (state.bmPrompts||[]).slice().reverse().slice(0, 24);
        const strong = list
          .map(p => ({ p, I: computePromptIntensity(p.text||"") }))
          .filter(x => x.I >= threshold);

        if(!strong.length) return null;
        // Prefer highest intensity but keep randomness
        strong.sort((a,b)=>b.I-a.I);
        const pick = strong[Math.floor(Math.random() * Math.min(6, strong.length))];
        const t = (pick.p.text||"").trim().replace(/\s+/g," ");
        return { text: t.slice(0, 180), intensity: pick.I };
      }

      function showBmGlimpse(gl){
        if(!gl) return;

        // Store current glimpse text for the film (avoid DOM text duplication / overlap)
        state.dreamFX.currentGlimpseText = gl.text || "";
        state.dreamFX.currentGlimpseIntensity = gl.intensity || 0;

        const bubble = els.dreamBmBubble;
        const film = els.dreamFilmCanvas;

        if(bubble){
          const pct = Math.round((gl.intensity||0)*100);
          // Keep bubble minimal (no long text) so it never overlaps the film caption.
          bubble.textContent = `BM glimpse (${pct}%)`;
          bubble.classList.add("show");
          setTimeout(()=>bubble.classList.remove("show"), Math.min(1200, state.dreamCfg.glimpseHoldMs));
        }

        if(film){
          film.classList.add("show");
          state.dreamFX.filmSeed = (Date.now() & 0xffffffff) ^ Math.floor((gl.intensity||0)*1e9);
          state.dreamFX.filmHoldUntil = Date.now() + state.dreamCfg.glimpseHoldMs;
        }
      }

      function startDreamEngine(){
        if(state.dreamFX.running) return;
        if(!els.dreamOverlay || !els.dreamCanvas) return;
        state.dreamFX.running = true;
        initDreamCanvasSize();
        initDreamParticles();
        state.dreamFX.t0 = performance.now();
        state.dreamFX.lastGlimpse = 0;
        state.dreamFX.nextGlimpseAt = performance.now() + 1200;
        state.dreamFX.lastTexture = 0;
        const loop = (now)=>{
          if(!state.dreamFX.running) return;
          drawDreamClouds(now);

          // Film rendering (only while active)
          if(els.dreamFilmCanvas && state.dreamFX.filmHoldUntil && Date.now() < state.dreamFX.filmHoldUntil){
            const captionText = state.dreamFX.currentGlimpseText || "";
            renderBmFilm(captionText, now);
          }else if(els.dreamFilmCanvas){
            els.dreamFilmCanvas.classList.remove("show");
          }

          // Trigger BM glimpses periodically (start after intro to avoid overlap)
          if(!state.dreamFX.nextGlimpseAt) state.dreamFX.nextGlimpseAt = now + 1200;
          if(now >= state.dreamFX.nextGlimpseAt){
            state.dreamFX.lastGlimpse = now;
            state.dreamFX.nextGlimpseAt = now + state.dreamCfg.glimpseEveryMs;
            const gl = pickBmGlimpse();
            if(gl) showBmGlimpse(gl);
          }

          state.dreamFX.rafId = requestAnimationFrame(loop);
        };
        state.dreamFX.rafId = requestAnimationFrame(loop);
      }

      function stopDreamEngine(){
        state.dreamFX.running = false;
        if(state.dreamFX.rafId){
          cancelAnimationFrame(state.dreamFX.rafId);
          state.dreamFX.rafId = 0;
        }
        state.dreamFX.currentGlimpseText = "";
        state.dreamFX.currentGlimpseIntensity = 0;
        state.dreamFX.filmHoldUntil = 0;
        if(els.dreamBmBubble) els.dreamBmBubble.classList.remove("show");
        if(els.dreamFilmCanvas) els.dreamFilmCanvas.classList.remove("show");
      }

      window.addEventListener("resize", () => {
        if(state.dreamFX.running){
          initDreamCanvasSize();
          initDreamParticles();
        }
      });

      /* =========================================================
         Intuition Agent (OFF by default)
         - Uses lightweight camera frame + optional mic energy
         - Keeps only scored frames (rest decays)
         - Weekly summary -> predictions + suggestions (offline-safe)
         ========================================================= */

      function loadIntuitionLog(){
        state.intuitionLog = safeLoadJSON(KEY_INTU, []);
      }
      function saveIntuitionLog(){
        localStorage.setItem(KEY_INTU, JSON.stringify(state.intuitionLog || []));
      }

      function toggleIntuition(){
        state.intuition.enabled = !state.intuition.enabled;
        saveCfg();
        showToast("Intuition: " + (state.intuition.enabled ? "on" : "off"));
      }

      function attachHiddenIntuitionToggle(){
        // No UI changes: triple-tap Sense status toggles Intuition.
        if(!els.senseStatus) return;
        let taps = 0;
        let last = 0;
        els.senseStatus.addEventListener("click", () => {
          const now = Date.now();
          if(now - last > 700) taps = 0;
          taps++;
          last = now;
          if(taps >= 3){
            taps = 0;
            toggleIntuition();
          }
        });
      }

      async function getTemporaryCameraStream(){
        try{
          if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return null;
          // If Sense camera is already on, reuse it.
          if(state.sense && state.sense.stream) return state.sense.stream;
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: "environment",
              width: { ideal: 320 },
              height: { ideal: 240 },
              frameRate: { ideal: 10, max: 15 }
            },
            audio: false
          });
          return stream;
        }catch(e){
          return null;
        }
      }

      function computeFrameLuma(ctx, w, h){
        // Sample a small grid to estimate brightness.
        try{
          const img = ctx.getImageData(0,0,w,h).data;
          let sum = 0, n = 0;
          const step = Math.max(4, Math.floor(Math.min(w,h)/18));
          for(let y=0; y<h; y+=step){
            for(let x=0; x<w; x+=step){
              const i = (y*w + x)*4;
              const r = img[i], g = img[i+1], b = img[i+2];
              const l = 0.2126*r + 0.7152*g + 0.0722*b;
              sum += l; n++;
            }
          }
          return n ? (sum/n) : 0;
        }catch(e){ return 0; }
      }

      function scoreFrameForKeep(ctx, w, h, luma){
        // Prefer not-too-dark, not-too-blown scenes + some visual complexity.
        let score = 0;
        const mid = 110;
        score += Math.max(0, 1 - Math.abs(luma - mid)/mid); // 0..1
        try{
          const img = ctx.getImageData(0,0,w,h).data;
          let varSum = 0, n = 0;
          const step = Math.max(6, Math.floor(Math.min(w,h)/22));
          for(let y=0; y<h; y+=step){
            for(let x=0; x<w; x+=step){
              const i = (y*w + x)*4;
              const l = 0.2126*img[i] + 0.7152*img[i+1] + 0.0722*img[i+2];
              // compare to right neighbor
              const j = (y*w + Math.min(w-1,x+step))*4;
              const lr = 0.2126*img[j] + 0.7152*img[j+1] + 0.0722*img[j+2];
              varSum += Math.abs(l - lr);
              n++;
            }
          }
          const edge = n ? (varSum/n) : 0;
          score += Math.min(1, edge/40); // 0..1
        }catch(e){}
        return Math.max(0, Math.min(1, score/2));
      }

      async function intuitionCaptureOnce(){
        if(!state.intuition.enabled) return;
        if(!state.intuition.cameraEnabled) return;
        if(document.hidden) return; // browsers usually stop camera in background
        const stream = await getTemporaryCameraStream();
        if(!stream) return;

        // Hidden video element (reuse Sense video if available)
        const video = els.senseVideo || document.createElement("video");
        video.playsInline = true;
        video.muted = true;

        if(!video.srcObject) video.srcObject = stream;

        // Wait for metadata if needed
        await new Promise(res=>{
          if(video.readyState >= 2) return res();
          video.onloadedmetadata = () => res();
          setTimeout(()=>res(), 800);
        });

        const w = Math.min(video.videoWidth || 320, 320);
        const h = Math.min(video.videoHeight || 240, 240);
        if(!w || !h) return;

        const c = document.createElement("canvas");
        c.width = w; c.height = h;
        const ctx = c.getContext("2d", { willReadFrequently: true });
        ctx.drawImage(video,0,0,w,h);
        // Intuition/Dream (optional): keep a tiny texture in-memory only (never stored in BM).
        try{
          if(state.intuition && state.intuition.enabled){
            const thumb = document.createElement("canvas");
            thumb.width = 160; thumb.height = 120;
            const tctx = thumb.getContext("2d");
            tctx.drawImage(c, 0,0, thumb.width, thumb.height);
            const dataUrl = thumb.toDataURL("image/jpeg", 0.55);
            const img = new Image();
            img.src = dataUrl;
            state.dreamFX.textures = state.dreamFX.textures || [];
            state.dreamFX.textures.unshift({ ts: Date.now(), score: 0.9, img });
            state.dreamFX.textures = state.dreamFX.textures.slice(0, 6);
          }
        }catch(e){}


        const luma = computeFrameLuma(ctx,w,h);
        const pocketLikely = luma < 18; // very dark ‚Üí pocket/covered
        if(pocketLikely){
          state.intuition.pocketDarkFrames = (state.intuition.pocketDarkFrames||0) + 1;
          // Do not store anything.
        }else{
          state.intuition.pocketDarkFrames = 0;
          const keepScore = scoreFrameForKeep(ctx,w,h,luma);
          // Keep only good frames; others decay immediately.
          if(keepScore >= 0.62){
            // Create a tiny thumbnail for Dream blending (in-memory only).
            const thumb = document.createElement("canvas");
            const tw = 160, th = 120;
            thumb.width = tw; thumb.height = th;
            const tctx = thumb.getContext("2d");
            tctx.drawImage(c, 0,0, tw, th);
            const dataUrl = thumb.toDataURL("image/jpeg", 0.55);

            // Cache in dream textures (not persisted)
            const img = new Image();
            img.src = dataUrl;
            state.dreamFX.textures = state.dreamFX.textures || [];
            state.dreamFX.textures.unshift({ ts: Date.now(), score: keepScore, img });
            state.dreamFX.textures = state.dreamFX.textures.slice(0, 6);

            // Store only minimal metadata for intuition (privacy friendly)
            const rec = { ts: Date.now(), luma: Math.round(luma), score: Number(keepScore.toFixed(2)) };
            // Keep last 40
            if(!state.intuition.samples) state.intuition.samples = [];
            state.intuition.samples.unshift(rec);
            state.intuition.samples = state.intuition.samples.slice(0, 40);
          }
        }

        state.intuition.lastCapture = Date.now();
        saveCfg();

        // If we created a separate stream (not Sense), stop it.
        if(stream && stream !== (state.sense && state.sense.stream)){
          try{ stream.getTracks().forEach(t=>t.stop()); }catch(e){}
          if(!els.senseVideo) video.srcObject = null;
        }
      }

      async function intuitionMicEnergyOnce(){
        if(!state.intuition.enabled) return;
        if(!state.intuition.micEnabled) return;
        if(document.hidden) return;
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;

        try{
          const stream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
          const ac = new (window.AudioContext || window.webkitAudioContext)();
          const src = ac.createMediaStreamSource(stream);
          const an = ac.createAnalyser();
          an.fftSize = 1024;
          src.connect(an);
          const buf = new Uint8Array(an.frequencyBinCount);

          let peak = 0;
          const start = Date.now();
          while(Date.now() - start < 1200){
            an.getByteFrequencyData(buf);
            let sum = 0;
            for(let i=0;i<buf.length;i+=8){ sum += buf[i]; }
            const v = sum / (buf.length/8) / 255;
            peak = Math.max(peak, v);
            await new Promise(r=>setTimeout(r, 80));
          }

          if(!state.intuition.sound) state.intuition.sound = [];
          state.intuition.sound.unshift({ ts: Date.now(), peak: Number(peak.toFixed(2)) });
          state.intuition.sound = state.intuition.sound.slice(0, 40);
          saveCfg();

          stream.getTracks().forEach(t=>t.stop());
          ac.close();
        }catch(e){}
      }

      function buildWeeklyIntuitionReport(){
        const now = new Date();
        const bm = (state.bmPrompts||[]).slice().reverse().slice(0, 18);
        const hist = (state.history||[]).slice().reverse().slice(0, 28);

        const textBag = [];
        bm.forEach(x => textBag.push(x.title||"", x.text||""));
        hist.forEach(x => textBag.push(x.text||""));
        const all = textBag.join(" ").toLowerCase();

        // Basic keyword extraction
        const stop = new Set(["the","and","for","with","that","this","from","your","you","are","was","were","have","has","had","but","not","can","will","just","into","over","more","less","very","about","what","when","where","then","than","them","they","their","our","ours","his","her","she","him","who"]);
        const words = all.replace(/[^a-z0-9\s]/g," ").split(/\s+/).filter(w=>w.length>=4 && !stop.has(w));
        const freq = new Map();
        for(const w of words){ freq.set(w, (freq.get(w)||0)+1); }
        const top = [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0,8).map(([w,c])=>w);

        // Light heuristics
        const recentStrong = bm.map(x=>computePromptIntensity(x.text||"")).filter(v=>v>=0.72).length;
        const energyPeak = (state.intuition.sound && state.intuition.sound.length) ? Math.max(...state.intuition.sound.map(s=>s.peak||0)) : 0;

        const predictions = [];
        const suggestions = [];

        if(top.length){
          predictions.push(`Your week will likely keep circling around: ${top.slice(0,4).join(", ")}.`);
        }else{
          predictions.push("Your week looks open-ended; your system has limited recent text signals.");
        }

        if(recentStrong >= 3){
          predictions.push("High-intensity memory signals are frequent; emotional carry-over is likely.");
          suggestions.push("Schedule a short recovery ritual after intense sessions (walk, water, breathing).");
        }else{
          predictions.push("Intensity seems moderate; steady progress is more likely than dramatic swings.");
          suggestions.push("Pick one clear milestone and close it (reduce context switching).");
        }

        if(energyPeak >= 0.55){
          predictions.push("Your environment noise level was sometimes high; interruptions may repeat.");
          suggestions.push("Create a 30‚Äì60 minute protected block for deep work (phone face-down).");
        }else{
          predictions.push("Ambient noise signal is low; your environment may support focus.");
          suggestions.push("Use the calm window to write 1‚Äì2 pages of your core narrative / research notes.");
        }

        // Always include AURA-X aligned advice
        suggestions.push("Convert 1‚Äì2 best moments into BM snapshots with a clear title and one actionable next step.");
        suggestions.push("If a single sentence crosses ~72% intensity, tag it and revisit later in Dream Mode.");

        const report =
`INTUITION (weekly)\nDate: ${now.toLocaleString()}\n\nSignals\n- BM items (recent): ${bm.length}\n- History items (recent): ${hist.length}\n- Top keywords: ${top.length ? top.join(", ") : "none"}\n- High-intensity BM glimpses (>=72%): ${recentStrong}\n- Sound peak (if enabled): ${energyPeak ? energyPeak.toFixed(2) : "n/a"}\n\nPredictions\n- ${predictions.join("\n- ")}\n\nSuggestions\n- ${suggestions.join("\n- ")}`;
        return report;
      }

      function runWeeklyIntuitionIfDue(){
        if(!state.intuition.enabled) return;
        const now = Date.now();
        const last = state.intuition.lastRun || 0;
        const weekMs = 7*24*60*60*1000;
        if(now - last < weekMs) return;

        const report = buildWeeklyIntuitionReport();
        state.intuition.lastRun = now;
        saveCfg();

        // Save and show
        if(!state.intuitionLog) state.intuitionLog = [];
        state.intuitionLog.unshift({ ts: now, text: report });
        state.intuitionLog = state.intuitionLog.slice(0, 24);
        saveIntuitionLog();

        addHistory("aura", report);
        logLine("sys", "Intuition generated (stored to history).");
        showToast("Intuition generated");
      }

      function intuitionTick(){
        if(!state.intuition.enabled) return;
        runWeeklyIntuitionIfDue();

        // Capture (camera + optional mic) at intervals
        const intervalMs = Math.max(5, Number(state.intuition.captureIntervalMin||30)) * 60*1000;
        const lastCap = state.intuition.lastCapture || 0;
        if(Date.now() - lastCap >= intervalMs){
          intuitionCaptureOnce();
          intuitionMicEnergyOnce();
        }
      }

      function startIntuitionTimer(){
        // Always start timer; it does nothing unless enabled.
        if(state._intuitionTimerId) return;
        state._intuitionTimerId = setInterval(intuitionTick, 30000);
      }

      function registerActivity(){
        if(els.dreamOverlay && els.dreamOverlay.classList.contains("show")) return;
        scheduleDreamTimer();
      }
      function saveCfg(){
        const cfg = {
          voiceOn: state.voiceOn,
          learningOn: state.learningOn,
          faithSelection: state.faithSelection,
          faithLiveOptions: state.faithLiveOptions,
          apiConfig: state.apiConfig,
          offlineReady: state.offlineReady,
          dream: { enabled: state.dreamEnabled, delayMs: state.dreamDelayMs, intensityThreshold: state.dreamCfg.intensityThreshold, glimpseEveryMs: state.dreamCfg.glimpseEveryMs, glimpseHoldMs: state.dreamCfg.glimpseHoldMs },
          intuition: { enabled: state.intuition.enabled, lastRun: state.intuition.lastRun, captureIntervalMin: state.intuition.captureIntervalMin, cameraEnabled: state.intuition.cameraEnabled, micEnabled: state.intuition.micEnabled }
        };
        localStorage.setItem(KEY_CFG, JSON.stringify(cfg));
      }
      function saveIntelligence(){ localStorage.setItem(KEY_INT, JSON.stringify(state.intelligence)); }
      function saveBM(){ localStorage.setItem(KEY_BM, JSON.stringify(state.bmPrompts)); }
      function saveHistory(){ localStorage.setItem(KEY_HIST, JSON.stringify(state.history)); }
      function saveUserIdentity(){ localStorage.setItem(KEY_USER, JSON.stringify(state.userIdentity)); }

      function saveSenseGallery(){ localStorage.setItem(KEY_SENSEG, JSON.stringify(state.senseGallery||[])); }

      // ---------- Media store (IndexedDB) for video blobs ----------
      const MEDIA_DB = "aurax_media_db_v1";
      const MEDIA_STORE = "media";
      let _mediaDbPromise = null;
      function openMediaDB(){
        if(!("indexedDB" in window)) return Promise.resolve(null);
        if(_mediaDbPromise) return _mediaDbPromise;
        _mediaDbPromise = new Promise((resolve)=>{
          const req = indexedDB.open(MEDIA_DB, 1);
          req.onupgradeneeded = ()=>{
            try{ req.result.createObjectStore(MEDIA_STORE); }catch(e){}
          };
          req.onsuccess = ()=>resolve(req.result);
          req.onerror = ()=>resolve(null);
        });
        return _mediaDbPromise;
      }
      async function idbPutBlob(key, blob){
        const db = await openMediaDB();
        if(!db) return false;
        return await new Promise((resolve)=>{
          const tx = db.transaction(MEDIA_STORE, "readwrite");
          tx.objectStore(MEDIA_STORE).put(blob, key);
          tx.oncomplete = ()=>resolve(true);
          tx.onerror = ()=>resolve(false);
        });
      }
      async function idbGetBlob(key){
        const db = await openMediaDB();
        if(!db) return null;
        return await new Promise((resolve)=>{
          const tx = db.transaction(MEDIA_STORE, "readonly");
          const req = tx.objectStore(MEDIA_STORE).get(key);
          req.onsuccess = ()=>resolve(req.result||null);
          req.onerror = ()=>resolve(null);
        });
      }

      function addDreamTextureFromDataUrl(dataUrl, score){
        try{
          if(!dataUrl) return;
          const img = new Image();
          img.src = dataUrl;
          state.dreamFX.textures = state.dreamFX.textures || [];
          state.dreamFX.textures.unshift({ ts: Date.now(), score: score==null?0.75:score, img });
          state.dreamFX.textures = state.dreamFX.textures.slice(0, 10);
        }catch(e){}
      }
      function hydrateDreamTexturesFromSense(){
        try{
          const g = state.senseGallery || [];
          if(!g.length) return;
          // Keep a few newest thumbnails in dream textures
          const newest = g.slice().sort((a,b)=>(b.ts||0)-(a.ts||0)).slice(0,6);
          newest.forEach(item=>{
            if(item && item.thumb){
              addDreamTextureFromDataUrl(item.thumb, 0.72);
            }
          });
        }catch(e){}
      }

      function dataUrlByteSize(dataUrl){
        try{
          const i = String(dataUrl||"").indexOf(",");
          if(i<0) return 0;
          const b64 = dataUrl.slice(i+1);
          const pad = (b64.endsWith("==")?2:(b64.endsWith("=")?1:0));
          return Math.max(0, Math.floor(b64.length*3/4) - pad);
        }catch(e){ return 0; }
      }
      async function fileToDataUrl(file){
        return await new Promise((resolve,reject)=>{
          const r = new FileReader();
          r.onload = ()=>resolve(String(r.result||""));
          r.onerror = ()=>reject(new Error("read failed"));
          r.readAsDataURL(file);
        });
      }
      async function compressImageDataUrl(dataUrl, maxDim, quality){
        return await new Promise((resolve)=>{
          const img = new Image();
          img.onload = ()=>{
            try{
              const w = img.width, h = img.height;
              const scale = Math.min(1, maxDim / Math.max(w,h));
              const cw = Math.max(1, Math.round(w*scale));
              const ch = Math.max(1, Math.round(h*scale));
              const c = document.createElement("canvas");
              c.width = cw; c.height = ch;
              const ctx = c.getContext("2d");
              ctx.drawImage(img,0,0,cw,ch);
              const out = c.toDataURL("image/jpeg", quality==null?0.72:quality);
              resolve({ dataUrl: out, w: cw, h: ch });
            }catch(e){ resolve({ dataUrl, w: img.width||0, h: img.height||0 }); }
          };
          img.onerror = ()=>resolve({ dataUrl, w:0, h:0 });
          img.src = dataUrl;
        });
      }
      async function makeVideoPosterDataUrl(file){
        // Create a lightweight poster frame for Dream textures + BM preview
        return await new Promise((resolve)=>{
          try{
            const url = URL.createObjectURL(file);
            const v = document.createElement("video");
            v.muted = true; v.playsInline = true;
            v.src = url;
            v.onloadeddata = ()=>{
              try{
                const w = v.videoWidth || 640;
                const h = v.videoHeight || 360;
                const maxDim = 360;
                const scale = Math.min(1, maxDim / Math.max(w,h));
                const cw = Math.max(1, Math.round(w*scale));
                const ch = Math.max(1, Math.round(h*scale));
                const c = document.createElement("canvas");
                c.width = cw; c.height = ch;
                const ctx = c.getContext("2d");
                ctx.drawImage(v, 0, 0, cw, ch);
                const out = c.toDataURL("image/jpeg", 0.62);
                URL.revokeObjectURL(url);
                resolve({ dataUrl: out, w: cw, h: ch });
              }catch(e){
                URL.revokeObjectURL(url);
                resolve({ dataUrl: "", w:0, h:0 });
              }
            };
            v.onerror = ()=>{
              try{ URL.revokeObjectURL(url); }catch(e){}
              resolve({ dataUrl: "", w:0, h:0 });
            };
          }catch(e){ resolve({ dataUrl: "", w:0, h:0 }); }
        });
      }

      // ---------- Offline "Prompt ‚Üí Image" (Poster) generator ----------
      function wrapTextLines(ctx, text, maxWidth){
        const words = String(text||"").replace(/\s+/g," ").trim().split(" ");
        const lines = [];
        let line = "";
        for(const w of words){
          const test = line ? (line + " " + w) : w;
          if(ctx.measureText(test).width <= maxWidth){
            line = test;
          }else{
            if(line) lines.push(line);
            line = w;
          }
        }
        if(line) lines.push(line);
        return lines;
      }

      function extractFirstMediaIdFromText(text){
        try{
          const m = String(text||"").match(/\[BM_MEDIA:([^\s\]]+)/);
          return m ? m[1] : null;
        }catch(e){ return null; }
      }

      async function renderPosterFromPrompt(promptText, baseMediaId){
        // Creates a stylized image locally (NOT AI). Useful as a "prompt card" / screensaver texture.
        return await new Promise((resolve)=>{
          try{
            const size = 1024;
            const c = document.createElement("canvas");
            c.width = size; c.height = size;
            const ctx = c.getContext("2d");

            // Background gradient
            const g = ctx.createLinearGradient(0,0,size,size);
            g.addColorStop(0, "#0b1220");
            g.addColorStop(0.45, "#0b2a3a");
            g.addColorStop(1, "#220b2a");
            ctx.fillStyle = g;
            ctx.fillRect(0,0,size,size);

            // Optional background image (from sense gallery)
            const bgItem = (baseMediaId && (state.senseGallery||[]).find(x=>x && x.id===baseMediaId && x.thumb)) || null;
            if(bgItem && bgItem.thumb){
              const img = new Image();
              img.onload = ()=>{
                try{
                  // cover draw
                  const iw = img.width || 1, ih = img.height || 1;
                  const scale = Math.max(size/iw, size/ih);
                  const dw = iw*scale, dh = ih*scale;
                  const dx = (size - dw)/2, dy = (size - dh)/2;
                  ctx.save();
                  ctx.globalAlpha = 0.35;
                  ctx.drawImage(img, dx, dy, dw, dh);
                  ctx.restore();

                  // Dark overlay for readability
                  ctx.fillStyle = "rgba(2,6,23,0.55)";
                  ctx.fillRect(0,0,size,size);

                  finish();
                }catch(e){ finish(); }
              };
              img.onerror = ()=>finish();
              img.src = bgItem.thumb;
            } else {
              finish();
            }

            function finish(){
              try{
                // Header
                ctx.fillStyle = "rgba(125,211,252,0.92)";
                ctx.font = "800 44px system-ui, -apple-system, Segoe UI, sans-serif";
                ctx.fillText("AURA-X Œ©", 64, 98);

                ctx.fillStyle = "rgba(229,231,235,0.72)";
                ctx.font = "600 18px system-ui, -apple-system, Segoe UI, sans-serif";
                const stamp = new Date().toLocaleString();
                ctx.fillText("Offline prompt card ¬∑ " + stamp, 64, 132);

                // Prompt box
                const pad = 56;
                const boxX = 64, boxY = 170, boxW = size - 128, boxH = size - 260;
                ctx.fillStyle = "rgba(2,6,23,0.62)";
                ctx.beginPath();
                roundRect(ctx, boxX, boxY, boxW, boxH, 24);
                ctx.fill();

                ctx.strokeStyle = "rgba(148,163,184,0.22)";
                ctx.lineWidth = 2;
                ctx.beginPath();
                roundRect(ctx, boxX, boxY, boxW, boxH, 24);
                ctx.stroke();

                // Text
                const clean = String(promptText||"").replace(/\[BM_MEDIA:[^\]]+\]/g,"").trim();
                ctx.fillStyle = "rgba(253,230,138,0.95)";
                ctx.font = "700 20px ui-monospace, Menlo, Consolas, monospace";
                const lines = wrapTextLines(ctx, clean || "‚Ä¶", boxW - pad*2);
                let y = boxY + 58;
                const maxLines = 22;
                for(let i=0; i<Math.min(lines.length, maxLines); i++){
                  ctx.fillText(lines[i], boxX + pad, y);
                  y += 32;
                }
                if(lines.length > maxLines){
                  ctx.fillStyle = "rgba(229,231,235,0.55)";
                  ctx.font = "600 16px ui-monospace, Menlo, Consolas, monospace";
                  ctx.fillText("‚Ä¶", boxX + pad, boxY + boxH - 34);
                }

                // Footer hint
                ctx.fillStyle = "rgba(229,231,235,0.55)";
                ctx.font = "600 16px system-ui, -apple-system, Segoe UI, sans-serif";
                ctx.fillText("This is NOT AI-generated. It's a local poster for prompts & Dream mode.", 64, size - 72);

                const out = c.toDataURL("image/jpeg", 0.88);
                resolve(out);
              }catch(e){
                try{ resolve(c.toDataURL("image/jpeg", 0.80)); }catch(_e){ resolve(null); }
              }
            }

          }catch(e){ resolve(null); }
        });
      }



      function attachPendingVisionToPromptText(text){
        const m = state.pendingVision;
        if(!m) return text;
        const tag = `[BM_MEDIA:${m.id} kind=${m.kind} name=${(m.name||"").replace(/\s+/g,"_")}]`;
        return (text ? (text + "\n\n" + tag) : tag);
      }

      function savePendingVisionToBM(){
        const bundle = state.pendingBundle;
        const single = state.pendingVision;

        // 1) Bundle save (multi-file)
        if(bundle && Array.isArray(bundle.files) && bundle.files.length){
          const note = (els.visionNote && els.visionNote.value || "").trim();
          const id = "bm_" + Date.now();
          const title = `BM bundle ¬∑ ${bundle.files.length} files`;
          const header = `[BM_BUNDLE:${bundle.id} files=${bundle.files.length}]`;
          const lines = bundle.files.map(f=>{
            const nm = (f.name||"file").replace(/\s+/g,"_");
            const mime = (f.mime||"");
            const kind = (f.kind||"file");
            const size = Number(f.size||0);
            return `- [BM_FILE:${f.id}] kind=${kind} name=${nm} bytes=${size} mime=${mime}`;
          }).join("\n");
          const text = (note ? (note + "\n\n" + header + "\n" + lines) : (header + "\n" + lines));

          state.bmPrompts.push({
            id, title, text, ts: Date.now(), locked: true,
            mediaBundleId: bundle.id,
            mediaIds: bundle.files.map(x=>x.id),
            attachments: bundle.files.map(x=>({id:x.id,name:x.name,kind:x.kind,mime:x.mime,size:x.size,thumb:x.thumb||null,full:x.full||null,hasBlob:!!x.hasBlob}))
          });

          saveBM();
          recomputeBMMetric();
          recomputeE0(0,0);
          updateCapsule();
          renderBMList();
          showToast("Saved bundle to BM");
          clearPendingBundleUI();
          try{ els.userInput && els.userInput.focus(); }catch(e){}
          return;
        }

        // 2) Single media save (existing dream-capture flow)
        if(single){
          const note = (els.visionNote && els.visionNote.value || "").trim();
          const id = "bm_"+Date.now();
          const title = single.kind==="video" ? "Sense video" : "Sense image";
          const tag = `[BM_MEDIA:${single.id} kind=${single.kind} name=${(single.name||"").replace(/\s+/g,"_")}]`;
          const text = (note ? (note + "\n\n" + tag) : tag);
          state.bmPrompts.push({ id, title, text, ts: Date.now(), locked: true, mediaIds:[single.id] });
          saveBM();
          saveSenseGallery();
          recomputeBMMetric();
          recomputeE0(0,0);
          updateCapsule();
          renderBMList();
          showToast("Saved to BM");
          return;
        }

        showToast("No files attached");
      }

      function persistLogicState(){
        const data = { list: state.logicPacks || [], activeIndex: state.logicActiveIndex };
        localStorage.setItem(KEY_LOGIC, JSON.stringify(data));
      }
      function addHistory(role,text){
        const item = { role, text, ts: Date.now(), locked: false };
        state.history.push(item);
        const cutoff = Date.now() - 48*60*60*1000;
        state.history = state.history.filter(h => h.locked || h.ts >= cutoff);
        saveHistory();
      }
      function toggleHistoryLock(idx){
        const h = state.history[idx];
        if(!h) return;
        h.locked = !h.locked;
        saveHistory();
        renderHistory();
      }
      function renderHistory(){
        els.historyBox.innerHTML = "";
        state.history.forEach((h,idx)=>{
          const row = document.createElement("div");
          row.className = "historyLine";
          const dt = new Date(h.ts).toLocaleString([], {hour:"2-digit",minute:"2-digit", day:"2-digit", month:"short"});
          const label = h.role==="user" ? "You" : (h.role==="aura" ? "AURA" : h.role);
          const left = document.createElement("div");
          left.className = "historyText";
          left.textContent = `[${dt}] ${label}: ${h.text}`;
          const btn = document.createElement("button");
          btn.className = "historyLock";
          btn.textContent = h.locked ? "üîí" : "üîì";
          btn.addEventListener("click", ()=>toggleHistoryLock(idx));
          row.appendChild(left);
          row.appendChild(btn);
          els.historyBox.appendChild(row);
        });
      }
      /* Faith chips & selection */
      function renderFaithChips(){
        els.faithChips.innerHTML = "";
        FAITH_OPTIONS.forEach(opt=>{
          const chip = document.createElement("button");
          chip.className = "chip" + (state.faithSelection.includes(opt.id) ? " active" : "");
          chip.textContent = opt.label;
          chip.addEventListener("click", ()=>{
            let newSel = [...state.faithSelection];
            if(opt.id==="none"){
              newSel = [];
            } else {
              if(newSel.includes(opt.id)){
                newSel = newSel.filter(x=>x!==opt.id);
              } else {
                newSel = newSel.filter(x=>x!=="none");
                newSel = [opt.id]; // one primary faith for bar
              }
            }
            applyFaithSelection(newSel);
          });
          els.faithChips.appendChild(chip);
        });
      }
      function showFaithCfgButtonForFaith(faithId){
        if(!els.faithCfgBtn) return;
        if(!faithId || faithId==="none"){
          els.faithCfgBtn.classList.remove("show");
          return;
        }
        els.faithCfgBtn.classList.add("show");
        state.currentFaithForCfg = faithId;
      }
      /* ‚úÖ UPDATED: meta empty => hidden */
      function setEthicText(main, meta){
        if(!els.ethicMain || !els.ethicBox) return;
        els.ethicMain.textContent = main;
        if(els.ethicMeta){
          const m = (meta || "").trim();
          els.ethicMeta.textContent = m;
          els.ethicMeta.style.display = m ? "block" : "none";
        }
        els.ethicBox.classList.remove("ethicPulse");
        void els.ethicBox.offsetWidth;
        els.ethicBox.classList.add("ethicPulse");
      }
      /* ‚úÖ UPDATED: only statement + translation (no lens/topic) */
      function setEthicFromFaith(faithId, topic){
        const options = state.faithLiveOptions[faithId] || {};
        if(options.enabled === false){
          setEthicText(ETHIC_BASE, ""); // meta hidden
          return;
        }
        const litPack = FAITH_LITERATURE[faithId];
        if(!litPack || !litPack.base){
          setEthicText(ETHIC_BASE, ""); // meta hidden
          return;
        }
        const base = litPack.base;
        let lang = options.lang || "auto";
        if(lang === "auto") lang = defaultDeviceLang;
        const trans = (base.translations?.[lang] || base.translations?.english || "").trim();
        setEthicText(base.original, trans); // ‚úÖ only two lines
      }
      function inferTopicFromText(t){
        const s = (t||"").toLowerCase();
        if(/death|cry|sad|hard|loss|grief|pain|tension|stress|problem|musibat|imtihan|broken/.test(s)) return "hardship";
        if(/thanks|thank you|shukr|shukar|grateful|gratitude|blessing|ne'mat|nimat|favou?r/.test(s)) return "gratitude";
        if(/mother|father|parents|family|friend|dost|wife|husband|relationship|brother|sister|bhai|behen/.test(s)) return "relationships";
        if(/health|doctor|hospital|ill|sick|fever|disease|bp|sugar|heart attack|medicine/.test(s)) return "health";
        if(/job|work|office|career|money|loan|business|project|study|exam|paper|marks|salary|promotion/.test(s)) return "work";
        if(/allah|god|jesus|quran|hadith|bible|gita|prayer|dua|tafsir|masjid|church|temple/.test(s)) return "faith";
        return "general";
      }
      /* ‚úÖ UPDATED: lens/topic meta removed for generic mode too */
      function updateEthicBar(latestUserText){
        if(!latestUserText) return;
        state.ethic.messageCount++;
        if(state.ethic.messageCount < 2) return;
        const topic = inferTopicFromText(latestUserText);
        const lensId = (state.faithSelection[0] || "none");
        const now = Date.now();
        if(topic === state.ethic.topic && lensId === state.ethic.lens && (now - state.ethic.lastUpdate) < 15000){
          return;
        }
        if(lensId !== "none"){
          setEthicFromFaith(lensId, topic);
        } else {
          const lensKey = ETHIC_LIBRARY[lensId] ? lensId : "general";
          const lib = ETHIC_LIBRARY[lensKey] || ETHIC_LIBRARY.general;
          const line = lib[topic] || lib.general || ETHIC_BASE;
          setEthicText(line, ""); // ‚úÖ no meta
        }
        state.ethic.topic = topic;
        state.ethic.lens = lensId;
        state.ethic.lastUpdate = now;
      }
      function startFaithFlight(){
        if(!els.faithBubble) return;
        state.faithFlightPending = false;
        state.faithFlightDone = true;
        els.faithBubble.classList.remove("pulse");
        els.faithBubble.classList.add("flying");
        const pill = document.querySelector(".pill");
        const onEnd = () => {
          els.faithBubble.classList.remove("show","flying");
          els.faithBubble.removeEventListener("animationend", onEnd);
          if(pill) pill.classList.add("faithGlow");
        };
        els.faithBubble.addEventListener("animationend", onEnd);
      }
      function onFaithChanged(){
        const newFaith = state.faithSelection[0] || "none";
        state.currentFaith = newFaith;
        els.faithLabel.textContent = state.faithSelection.length ? state.faithSelection.join(", ") : "none";
        const pill = document.querySelector(".pill");
        if(newFaith === "none"){
          state.currentFaithForCfg = null;
          state.faithFlightPending = false;
          state.faithFlightDone = false;
          if(els.faithCfgBtn) els.faithCfgBtn.classList.remove("show");
          if(els.faithBubble){
            els.faithBubble.classList.remove("show","pulse","flying");
          }
          if(pill) pill.classList.remove("faithGlow");
          setEthicText(ETHIC_BASE,""); // ‚úÖ no meta
          state.ethic.lens = "none";
          saveCfg();
          return;
        }
        // New faith selected
        showFaithCfgButtonForFaith(newFaith);
        // Bubble text
        if(els.faithBubble){
          const label = FAITH_OPTIONS.find(f=>f.id===newFaith)?.label || newFaith;
          els.faithBubbleTitle.textContent = "Faith lens: " + label;
          els.faithBubbleMeta.textContent = "You'll get updates according to your selected faith above. üê¶";
          els.faithBubble.classList.remove("flying");
          els.faithBubble.classList.add("show","pulse");
        }
        state.faithFlightPending = true;
        state.faithFlightDone = false;
        saveCfg();
      }
      function applyFaithSelection(newSel){
        state.faithSelection = newSel || [];
        renderFaithChips();
        onFaithChanged();
        saveCfg();
      }
      /* Faith bubble -> article modal (optional) */
      function maybeShowFaithBubble(){
        if(!state.faithSelection.length) return;
        const pick = state.faithSelection[0];
        const list = FAITH_LITERATURE[pick];
        if(!list) return;
        const art = list.base;
        state.currentFaithArticle = { id: pick+"_base", title: "Core ethic line", short: "Short reflection from selected literature.", content: art.translations[defaultDeviceLang] || art.translations.english };
        els.faithBubbleTitle.textContent = "Faith reflection";
        els.faithBubbleMeta.textContent = "Tap to open a short reflection.";
        els.faithBubble.classList.add("show");
      }
      function openModal(el){ el.classList.add("show"); }
      function closeModalById(id){
        if(id==="modalSense") cleanupSense();
        const el = document.getElementById(id);
        if(el) el.classList.remove("show");
      }
      document.body.addEventListener("click",(e)=>{
        const target = e.target;
        if(target.dataset && target.dataset.close){
          closeModalById(target.dataset.close);
        }
        if(target.classList && target.classList.contains("modalOverlay") && !target.classList.contains("noClose")){
          if(target.id==="modalSense") cleanupSense();
          target.classList.remove("show");
        }
      });
      if(els.faithBubble){
        els.faithBubble.addEventListener("click",()=>{
          if(!state.currentFaithArticle) return;
          const art = state.currentFaithArticle;
          const meta = `Lens: ${state.faithSelection.join(", ") || "none"} ¬∑ id=${art.id||"base"}`;
          els.faithArticleMeta.textContent = meta;
          els.faithArticleTitle.textContent = art.title || "Faith reflection";
          els.faithArticleText.value = art.content || "";
          openModal(els.modalFaithArticle);
        });
      }
      if(els.faithBubbleClose){
        els.faithBubbleClose.addEventListener("click",(ev)=>{
          ev.stopPropagation();
          els.faithBubble.classList.remove("show","pulse","flying");
        });
      }
      els.btnCopyFaithArticle.addEventListener("click",()=>{
        navigator.clipboard?.writeText(els.faithArticleText.value||"");
        showToast("Faith reflection copied");
      });
      els.btnExportFaithArticle.addEventListener("click",()=>{
        const title = (els.faithArticleTitle.textContent || "faith_reflection").replace(/[^\w\-]+/g,"_");
        const blob = new Blob([els.faithArticleText.value || ""], {type:"text/plain;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = title + ".txt";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast("Exported as text file");
      });
      els.btnSkipFaithBM.addEventListener("click",()=>{
        closeModalById("modalFaithArticle");
      });
      /* Faith live bar config modal */
      if(els.faithCfgBtn){
        els.faithCfgBtn.addEventListener("click",()=>{
          const fid = state.currentFaithForCfg;
          if(!fid || fid==="none") return;
          const opt = state.faithLiveOptions[fid] || { enabled:true, lang:"auto" };
          const label = FAITH_OPTIONS.find(f=>f.id===fid)?.label || fid;
          els.faithCfgFaithName.textContent = label;
          els.faithCfgFaithTitle.textContent = "Configure live bar for "+label;
          els.faithCfgEnable.checked = opt.enabled !== false;
          els.faithCfgLang.value = opt.lang || "auto";
          openModal(els.modalFaithCfg);
        });
      }
      if(els.faithCfgSave){
        els.faithCfgSave.addEventListener("click",()=>{
          const fid = state.currentFaithForCfg;
          if(!fid || fid==="none") return;
          const enabled = els.faithCfgEnable.checked;
          const lang = els.faithCfgLang.value || "auto";
          state.faithLiveOptions[fid] = { enabled, lang };
          saveCfg();
          if(els.faithCfgBtn) els.faithCfgBtn.classList.remove("show");
          closeModalById("modalFaithCfg");
          showToast("Faith live bar updated");
          if(enabled){
            setEthicFromFaith(fid, state.ethic.topic || "general");
          } else {
            setEthicText(ETHIC_BASE,""); // ‚úÖ no meta
          }
        });
      }
      /* Intelligence rendering */
      function renderIntelligence(filter=""){
        els.intelList.innerHTML = "";
        const q = (filter||"").toLowerCase();
        const list = state.intelligence.filter(item=>{
          if(!q) return true;
          return (item.q||"").toLowerCase().includes(q) || (item.a||"").toLowerCase().includes(q);
        });
        if(!list.length){
          const p = document.createElement("div");
          p.style.fontSize = "12px";
          p.style.opacity = "0.65";
          p.textContent = "No intelligence stored yet.";
          els.intelList.appendChild(p);
          return;
        }
        list.forEach(item=>{
          const card = document.createElement("div");
          card.className = "intelCard";
          const top = document.createElement("div");
          top.className = "intelTop";
          const qDiv = document.createElement("div");
          qDiv.className = "intelQ";
          qDiv.textContent = "Q: " + item.q;
          const meta = document.createElement("div");
          meta.className = "intelMeta";
          const dt = new Date(item.ts||Date.now()).toLocaleString();
          meta.textContent = `id=${item.id} ¬∑ ${dt}`;
          top.appendChild(qDiv);
          top.appendChild(meta);
          const aDiv = document.createElement("div");
          aDiv.className = "intelA";
          aDiv.textContent = "A: " + item.a;
          const btns = document.createElement("div");
          btns.className = "intelButtons";
          const bEdit = document.createElement("button");
          bEdit.className = "btn btnBlue";
          bEdit.textContent = "Edit";
          const bDelete = document.createElement("button");
          bDelete.className = "btn btnRed";
          bDelete.textContent = "Delete";
          const bCopy = document.createElement("button");
          bCopy.className = "btn btnBlue";
          bCopy.textContent = "Copy";
          bCopy.addEventListener("click",()=>{
            navigator.clipboard?.writeText(`Q: ${item.q}\nA: ${item.a}`);
            showToast("Pair copied");
          });
          bDelete.addEventListener("click",()=>{
            if(!confirm("Delete this Q‚ÜíA pair?")) return;
            state.intelligence = state.intelligence.filter(x=>x.id!==item.id);
            saveIntelligence();
            renderIntelligence(els.intelSearch.value);
            showToast("Deleted");
          });
          bEdit.addEventListener("click",()=>{
            state.editingIntelId = (state.editingIntelId === item.id) ? null : item.id;
            renderIntelligence(els.intelSearch.value);
          });
          btns.appendChild(bEdit);
          btns.appendChild(bCopy);
          btns.appendChild(bDelete);
          card.appendChild(top);
          card.appendChild(aDiv);
          card.appendChild(btns);
          if(state.editingIntelId === item.id){
            const editBlock = document.createElement("div");
            editBlock.className = "intelEditBlock";
            const qi = document.createElement("input");
            qi.className = "intelEditInput";
            qi.value = item.q;
            const ai = document.createElement("textarea");
            ai.className = "intelEditArea";
            ai.value = item.a;
            const row = document.createElement("div");
            row.style.display = "flex";
            row.style.gap = "8px";
            row.style.marginTop = "6px";
            row.style.flexWrap = "wrap";
            const bSave = document.createElement("button");
            bSave.className = "btn btnGreen";
            bSave.textContent = "Save";
            const bCancel = document.createElement("button");
            bCancel.className = "btn btnRed";
            bCancel.textContent = "Cancel";
            bSave.addEventListener("click",()=>{
              item.q = qi.value.trim();
              item.a = ai.value.trim();
              item.ts = item.ts || Date.now();
              saveIntelligence();
              state.editingIntelId = null;
              renderIntelligence(els.intelSearch.value);
              showToast("Updated");
            });
            bCancel.addEventListener("click",()=>{
              state.editingIntelId = null;
              renderIntelligence(els.intelSearch.value);
            });
            row.appendChild(bSave);
            row.appendChild(bCancel);
            editBlock.appendChild(qi);
            editBlock.appendChild(ai);
            editBlock.appendChild(row);
            card.appendChild(editBlock);
          }
          els.intelList.appendChild(card);
        });
      }
      els.intelSearch.addEventListener("input",()=>renderIntelligence(els.intelSearch.value));
      /* Seed parsing */
      function parseSeedBlock(text){
        const lines = text.split(/\r?\n/);
        const joined = lines.join("\n");
        const regex = /\\item\s*(.+?)\s*\\textbf\{A:\}\s*([\s\S]*?)(?=\\item|$)/g;
        const out = [];
        let m;
        while((m = regex.exec(joined))!==null){
          const q = m[1].trim();
          const rawA = m[2].trim();
          let a = rawA;
          const bracket = rawA.match(/^\[.*?\]\s*(.*)$/s);
          if(bracket) a = bracket[1].trim();
          if(q && a){
            out.push({ id:"seed_"+(Date.now()+"_"+out.length), q, a, ts:Date.now() });
          }
        }
        return out;
      }
      els.btnParseSeed.addEventListener("click",()=>{
        const txt = els.seedBox.value.trim();
        if(!txt){ els.seedHint.textContent = "Nothing to parse."; return; }
        const parsed = parseSeedBlock(txt);
        state.parsedSeed = parsed;
        els.seedHint.textContent = `Parsed ${parsed.length} Q‚ÜíA pairs (not saved yet).`;
      });
      els.btnSaveSeed.addEventListener("click",()=>{
        if(!state.parsedSeed.length){
          els.seedHint.textContent = "Nothing parsed yet.";
          return;
        }
        state.seedPairs = state.seedPairs.concat(state.parsedSeed);
        state.parsedSeed = [];
        els.seedHint.textContent = "Saved into seed memory.";
        els.seedBox.value = "";
        showToast("Seed updated");
      });
      els.btnDiscardSeed.addEventListener("click",()=>{
        els.seedBox.value = "";
        state.parsedSeed = [];
        els.seedHint.textContent = "Discarded block.";
      });
      /* Logic packs */
      function applyLogicPack(idx){
        state.logicActiveIndex = idx;
        if(idx==null || !state.logicPacks[idx]) return;
        const pack = state.logicPacks[idx];
        state.logicFaithSoftener = pack.faithSoftener !== false;
        if(pack.ui){
          if(pack.ui.theme === "golden"){
            document.body.classList.add("theme-golden");
          } else {
            document.body.classList.remove("theme-golden");
          }
          if(pack.ui.accentColor){
            document.documentElement.style.setProperty("--accent-color", pack.ui.accentColor);
          }
        }
        persistLogicState();
      }
      els.btnValidateLogic.addEventListener("click",()=>{
        try{
          JSON.parse(els.logicBox.value);
          els.logicHint.textContent = "Valid JSON.";
          showToast("Logic JSON valid");
        }catch(e){
          els.logicHint.textContent = "Invalid JSON: "+e.message;
        }
      });
      els.btnSaveLogic.addEventListener("click",()=>{
        try{
          const obj = JSON.parse(els.logicBox.value);
          obj.serial = obj.serial || ("L"+(state.logicPacks.length+1));
          state.logicPacks.push(obj);
          els.logicSerial.textContent = obj.serial;
          els.logicHint.textContent = "Saved as "+obj.serial;
          applyLogicPack(state.logicPacks.length-1);
          persistLogicState();
          showToast("Logic pack saved");
        }catch(e){
          els.logicHint.textContent = "Cannot save: invalid JSON.";
        }
      });
      els.btnCopyLogic.addEventListener("click",()=>{
        navigator.clipboard?.writeText(els.logicBox.value||"");
        showToast("Logic copied");
      });
      els.btnDeleteLogic.addEventListener("click",()=>{
        if(state.logicActiveIndex==null || !state.logicPacks[state.logicActiveIndex]){
          els.logicHint.textContent = "No active logic pack.";
          return;
        }
        if(!confirm("Delete current logic pack?")) return;
        state.logicPacks.splice(state.logicActiveIndex,1);
        state.logicActiveIndex = null;
        els.logicSerial.textContent = "none";
        els.logicHint.textContent = "Deleted.";
        document.body.classList.remove("theme-golden");
        document.documentElement.style.setProperty("--accent-color", "#0ea5e9");
        persistLogicState();
      });
      /* BM list & viewer */
      function renderBMList(){
        els.bmSelectList.innerHTML = "";
        const q = (els.bmSearch.value||"").toLowerCase();
        const d = (els.bmDate.value||"");
        const list = state.bmPrompts.filter(b=>{
          let ok = true;
          if(q){
            ok = (b.title||"").toLowerCase().includes(q) || (b.text||"").toLowerCase().includes(q);
          }
          if(ok && d){
            const dStr = new Date(b.ts||Date.now()).toISOString().slice(0,10);
            ok = (dStr === d);
          }
          return ok;
        }).sort((a,b)=> (b.ts||0)-(a.ts||0));
        if(!list.length){
          const div = document.createElement("div");
          div.style.fontSize = "12px";
          div.style.opacity = "0.65";
          div.textContent = "No BM prompts yet.";
          els.bmSelectList.appendChild(div);
          return;
        }
        list.forEach(bm=>{
          const item = document.createElement("div");
          item.className = "bmItem";
          const left = document.createElement("div");
          const title = document.createElement("div");
          title.className = "bmItemTitle";
          title.textContent = bm.title||"(untitled)";
          const meta = document.createElement("div");
          meta.className = "bmItemMeta";
          const ds = new Date(bm.ts||Date.now()).toISOString().slice(0,10);
          meta.textContent = ds + (bm.locked ? " ¬∑ üîí" : "");
          left.appendChild(title);
          left.appendChild(meta);
          item.appendChild(left);
          item.addEventListener("click",()=>selectBM(bm.id));
          els.bmSelectList.appendChild(item);
        });
      }
      function selectBM(id){
        const bm = state.bmPrompts.find(x=>x.id===id);
        state.selectedBMId = id;
        if(!bm){
          els.bmViewer.style.display = "none";
          return;
        }
        els.bmViewer.style.display = "block";
        els.bmTitle.textContent = bm.title||"Prompt";
        const ds = new Date(bm.ts||Date.now()).toLocaleString();
        const live = bm.liveUntil && bm.liveUntil > Date.now();
        els.bmMeta.textContent = ds + (bm.locked ? " ¬∑ locked" : " ¬∑ editable") + (live ? " ¬∑ LIVE 12h" : "");
        els.bmTextArea.value = bm.text||"";
        els.bmTextArea.readOnly = true;
        els.bmLockIcon.textContent = bm.locked ? "üîí" : "üîì";
        els.btnUnlockBM.style.display = bm.locked ? "inline-flex" : "none";
        els.btnLiveBM.textContent = live ? "Live 12h: on" : "Live 12h: off";
      }
      els.bmSearch.addEventListener("input", renderBMList);
      els.bmDate.addEventListener("change", ()=>{
        renderBMList();
        const d = els.bmDate.value;
        if(d){
          const found = state.bmPrompts.find(b=>{
            const ds = new Date(b.ts||Date.now()).toISOString().slice(0,10);
            return ds === d;
          });
          if(found) selectBM(found.id);
        }
      });
      els.btnLiveBM.addEventListener("click",()=>{
        if(!state.selectedBMId) return;
        const bm = state.bmPrompts.find(x=>x.id===state.selectedBMId);
        if(!bm) return;
        const now = Date.now();
        if(bm.liveUntil && bm.liveUntil > now){
          bm.liveUntil = null;
        } else {
          bm.liveUntil = now + 12*60*60*1000;
        }
        saveBM();
        renderBMList();
        selectBM(bm.id);
      });
      els.btnUnlockBM.addEventListener("click",()=>{
        if(!state.selectedBMId) return;
        const bm = state.bmPrompts.find(x=>x.id===state.selectedBMId);
        if(!bm) return;
        if(!confirm("Unlock this BM prompt for editing?")) return;
        bm.locked = false;
        saveBM();
        renderBMList();
        selectBM(bm.id);
      });
      els.btnCopyPrompt.addEventListener("click",()=>{
        if(!state.selectedBMId) return;
        const bm = state.bmPrompts.find(x=>x.id===state.selectedBMId);
        if(!bm) return;
        navigator.clipboard?.writeText(bm.text||"");
        showToast("BM prompt copied");
      });
      els.btnAutoGen.addEventListener("click", async ()=>{
        if(!state.selectedBMId){ showToast("Select a BM prompt first"); return; }
        const bm = state.bmPrompts.find(x=>x.id===state.selectedBMId);
        if(!bm){ showToast("BM not found"); return; }
        const prompt = String(bm.text||"").trim();
        if(!prompt){ showToast("BM prompt is empty"); return; }

        // Try to use an attached BM_MEDIA (if any) as the background texture
        const baseMediaId = extractFirstMediaIdFromText(prompt);

        showToast("Generating image‚Ä¶");
        const poster = await renderPosterFromPrompt(prompt, baseMediaId);
        if(!poster){ showToast("Could not generate image"); return; }

        // Store into Sense Gallery like a camera image, then attach for saving to BM
        const genId = "gen_" + Date.now();
        const thumbObj = await compressImageDataUrl(poster, 360, 0.64);
        const fullObj = await compressImageDataUrl(poster, 1100, 0.74);
        const fullBytes = dataUrlByteSize(fullObj.dataUrl);
        const keepFull = fullBytes <= 900*1024;

        const item = {
          id: genId,
          ts: Date.now(),
          kind: "image",
          name: ("BM_generated_" + (new Date().toISOString().slice(0,10)) + ".jpg"),
          mime: "image/jpeg",
          size: fullBytes,
          w: fullObj.w, h: fullObj.h,
          thumb: thumbObj.dataUrl,
          full: keepFull ? fullObj.dataUrl : null,
          generatedFrom: bm.id
        };

        state.senseGallery = state.senseGallery || [];
        state.senseGallery.unshift(item);
        state.senseGallery = state.senseGallery.slice(0, 40);
        saveSenseGallery();

        state.pendingVision = item;

        // Show preview area on the main screen so user can Save to BM
        if(els.imagePreviewArea) els.imagePreviewArea.style.display = "block";
        if(els.imgPrev){
          els.imgPrev.src = item.full || item.thumb;
          els.imgPrev.style.display = "block";
        }
        if(els.vidPrev){ els.vidPrev.style.display = "none"; els.vidPrev.src = ""; }
        if(els.visionHint) els.visionHint.textContent = "Generated image attached ¬∑ You can Save to BM";
        if(els.visionNote) els.visionNote.value = "Generated from BM: " + (bm.title || bm.id);

        addDreamTextureFromDataUrl(item.thumb, 0.78);
        showToast("Image ready. Tap 'Save to BM' to store it.");
      });
      els.btnDeletePrompt.addEventListener("click",()=>{
        if(!state.selectedBMId) return;
        const bm = state.bmPrompts.find(x=>x.id===state.selectedBMId);
        if(!bm) return;
        if(!confirm("Delete this BM prompt?")) return;
        if(!confirm("Are you sure? This cannot be undone.")) return;
        state.bmPrompts = state.bmPrompts.filter(x=>x.id!==bm.id);
        state.selectedBMId = null;
        saveBM();
        recomputeBMMetric();
        recomputeE0(0,0);
        updateCapsule();
        renderBMList();
        els.bmViewer.style.display = "none";
        showToast("BM prompt deleted");
      });
      if(els.btnToggleDream){
        els.btnToggleDream.addEventListener("click",()=>{
          state.dreamEnabled = !state.dreamEnabled;
          if(!state.dreamEnabled){
            if(state.dreamTimerId){ clearTimeout(state.dreamTimerId); state.dreamTimerId = null; }
            // Ensure Dream engine stops and overlay fully closes
            if(els.dreamOverlay && els.dreamOverlay.classList.contains("show")){
              hideDreamOverlay();
            }else{
              stopDreamEngine();
              els.dreamOverlay && els.dreamOverlay.classList.remove("show","intro","deep");
            }
          }
          updateDreamUI();
          saveCfg();
          scheduleDreamTimer();
        });
      }
      if(els.dreamDelaySelect){
        els.dreamDelaySelect.addEventListener("change",()=>{
          const v = parseInt(els.dreamDelaySelect.value,10);
          if(!isNaN(v)){
            state.dreamDelayMs = v;
            updateDreamUI();
            saveCfg();
            scheduleDreamTimer();
          }
        });
      }
      if(els.btnTestDream && els.dreamOverlay){
        els.btnTestDream.addEventListener("click",()=>{ showDreamOverlay(); });
      }
      if(els.dreamOverlay){
        const exitDream = (e)=>{
          if(!els.dreamOverlay.classList.contains("show")) return;
          try{ e && e.preventDefault && e.preventDefault(); }catch(_e){}
          try{ e && e.stopPropagation && e.stopPropagation(); }catch(_e){}
          hideDreamOverlay();
        };
        // Mobile browsers sometimes delay / skip click; pointer/touch makes exit reliable.
        els.dreamOverlay.addEventListener("pointerdown", exitDream, {passive:false});
        els.dreamOverlay.addEventListener("touchstart", exitDream, {passive:false});
        els.dreamOverlay.addEventListener("mousedown", exitDream, {passive:false});
        els.dreamOverlay.addEventListener("click", exitDream, {passive:false});
      }
      // Escape / keyboard exit (desktop)
      document.addEventListener("keydown", (e)=>{
        if(e.key === "Escape" && els.dreamOverlay && els.dreamOverlay.classList.contains("show")){
          hideDreamOverlay();
        }
      });
      /* Identity */
      function loadIdentityIntoForm(){
        const u = state.userIdentity || {};
        els.uName.value = u.name || "";
        els.uNick.value = u.nick || "";
        els.uOrigin.value = u.origin || "";
        els.uPlace.value = u.place || "";
        els.uProfession.value = u.profession || "";
        els.uEmotionalStyle.value = u.emotionalStyle || "";
        els.uKeyPeople.value = u.keyPeople || "";
        els.uLegacyRules.value = u.legacyRules || "";
      }
      els.btnEditIdentity.addEventListener("click",()=>{
        [els.uName,els.uNick,els.uOrigin,els.uPlace,els.uProfession,
         els.uEmotionalStyle,els.uKeyPeople,els.uLegacyRules].forEach(el=>el.removeAttribute("readonly"));
        showToast("Identity fields unlocked for edit");
      });
      els.btnSaveUserIdentity.addEventListener("click",()=>{
        state.userIdentity = {
          name: els.uName.value.trim(),
          nick: els.uNick.value.trim(),
          origin: els.uOrigin.value.trim(),
          place: els.uPlace.value.trim(),
          profession: els.uProfession.value.trim(),
          emotionalStyle: els.uEmotionalStyle.value.trim(),
          keyPeople: els.uKeyPeople.value.trim(),
          legacyRules: els.uLegacyRules.value.trim(),
          ts: Date.now()
        };
        saveUserIdentity();
        [els.uName,els.uNick,els.uOrigin,els.uPlace,els.uProfession,
         els.uEmotionalStyle,els.uKeyPeople,els.uLegacyRules].forEach(el=>el.setAttribute("readonly","readonly"));
        showToast("Identity saved locally");
      });
      els.btnDeleteUserIdentity.addEventListener("click",()=>{
        if(!confirm("Delete stored identity data?")) return;
        if(!confirm("Are you sure?")) return;
        state.userIdentity = null;
        localStorage.removeItem(KEY_USER);
        [els.uName,els.uNick,els.uOrigin,els.uPlace,els.uProfession,
         els.uEmotionalStyle,els.uKeyPeople,els.uLegacyRules].forEach(el=>el.value="");
        showToast("Identity deleted");
      });
      /* LLM */
      els.btnSaveLLM.addEventListener("click",()=>{
        state.apiConfig = {
          endpoint: els.apiEndpoint.value.trim(),
          model: els.apiModel.value.trim(),
          key: els.apiKey.value.trim()
        };
        saveCfg();
        showToast("LLM config saved");
      });
      async function loadOfflineModel(){
        if(!window.webllm){
          els.offlineStatus.textContent = "WebLLM not available.";
          return;
        }
        if(state.offlineReady || state.offlineLoading) return;
        try{
          state.offlineLoading = true;
          els.offlineStatus.textContent = "loading‚Ä¶";
          els.offlineBar.style.width = "25%";
          const engine = await window.webllm.CreateMLCEngine(OFFLINE_MODEL_ID, {
            initProgressCallback: (p)=>{
              const pct = Math.round((p.progress||0)*100);
              els.offlineBar.style.width = pct+"%";
            }
          });
          state.offlineEngine = engine;
          state.offlineReady = true;
          state.offlineLoading = false;
          els.offlineStatus.textContent = "ready";
          els.offlineBar.style.width = "100%";
          saveCfg();
          showToast("Offline model ready");
        }catch(e){
          state.offlineLoading = false;
          els.offlineStatus.textContent = "error";
          showToast("Offline model error");
        }
      }
      els.btnLoadOffline.addEventListener("click", loadOfflineModel);
      async function callOfflineLLM(prompt){
        if(!state.offlineReady || !state.offlineEngine) return null;
        try{
          const reply = await state.offlineEngine.chatCompletion({
            messages:[{role:"user",content:prompt}],
            stream:false
          });
          const text = reply?.choices?.[0]?.message?.content || "";
          return text.trim() || null;
        }catch{
          return null;
        }
      }
      async function callOnlineLLM(prompt){
        const {endpoint,model,key} = state.apiConfig;
        if(!endpoint || !model || !key) return null;
        try{
          const resp = await fetch(endpoint,{
            method:"POST",
            headers:{
              "Content-Type":"application/json",
              "Authorization":"Bearer "+key
            },
            body:JSON.stringify({
              model,
              messages:[{role:"user",content:prompt}],
              temperature:0.7
            })
          });
          if(!resp.ok) return null;
          const data = await resp.json();
          const text = data.choices?.[0]?.message?.content || "";
          return text.trim() || null;
        }catch{
          return null;
        }
      }
      /* Options */
      els.btnOptions.addEventListener("click",()=>{ els.optionsMenu.classList.toggle("show"); });
      els.miVoice.addEventListener("click",()=>{
        state.voiceOn = !state.voiceOn;
        els.voicePill.textContent = state.voiceOn ? "on" : "off";
        els.voicePill.className = state.voiceOn ? "pillOn" : "pillOff";
        saveCfg();
      });
      els.miLearn.addEventListener("click",()=>{
        state.learningOn = !state.learningOn;
        els.learnPill.textContent = state.learningOn ? "on" : "off";
        els.learnPill.className = state.learningOn ? "pillOn" : "pillOff";
        saveCfg();
      });
      els.miFaith.addEventListener("click",()=>openModal(els.modalFaith));
      els.miIntel.addEventListener("click",()=>openModal(els.modalIntel));
      els.miSeed.addEventListener("click",()=>openModal(els.modalSeed));
      els.miLLM.addEventListener("click",()=>openModal(els.modalLLM));
      els.miBMRecall.addEventListener("click",()=>openModal(els.modalBM));
      els.miHistory.addEventListener("click",()=>{renderHistory();openModal(els.modalHistory);});
      
      els.miSense && els.miSense.addEventListener("click",()=>openModal(els.modalSense));
els.miIdentity.addEventListener("click",()=>{loadIdentityIntoForm();openModal(els.modalIdentity);});
      /* History buttons */
      els.btnDeleteRecent.addEventListener("click",()=>{
        const cutoff = Date.now() - 48*60*60*1000;
        state.history = state.history.filter(h=>h.locked || h.ts < cutoff);
        saveHistory();
        renderHistory();
      });
      els.btnDeleteAllHist.addEventListener("click",()=>{
        if(!confirm("Delete all history (except locked)?")) return;
        state.history = state.history.filter(h=>h.locked);
        saveHistory();
        renderHistory();
      });
      els.btnCopyHistory.addEventListener("click",()=>{
        const text = state.history.map(h=>{
          const dt = new Date(h.ts).toLocaleString();
          const label = h.role==="user" ? "You" : (h.role==="aura" ? "AURA" : h.role);
          return `[${dt}] ${label}: ${h.text}`;
        }).join("\n");
        navigator.clipboard?.writeText(text);
        showToast("History copied");
      });
      /* Media (image/video) attach + BM save */
      async function handleVisionFile(file){
        // Backward-compatible single-file handler (kept for older flows)
        if(!file) return;
        await handleVisionFiles([file]);
      }

      function classifyVisionFile(file){
        const name = String(file?.name||"file");
        const mime = String(file?.type||"");
        const lower = name.toLowerCase();
        const ext = (lower.includes(".") ? lower.split(".").pop() : "");
        const isImage = mime.startsWith("image/");
        const isVideo = mime.startsWith("video/");
        const isAudio = mime.startsWith("audio/");
        const isPdf = mime==="application/pdf" || ext==="pdf";
        const isText = mime.startsWith("text/") || ["txt","md","json","csv","log"].includes(ext);
        const isDoc = ["doc","docx"].includes(ext) || mime.includes("msword") || mime.includes("wordprocessingml");
        const isPpt = ["ppt","pptx"].includes(ext) || mime.includes("powerpoint") || mime.includes("presentationml");
        const isXls = ["xls","xlsx"].includes(ext) || mime.includes("excel") || mime.includes("spreadsheetml");
        let kind = "file";
        if(isImage) kind="image";
        else if(isVideo) kind="video";
        else if(isAudio) kind="audio";
        else if(isPdf) kind="pdf";
        else if(isDoc) kind="doc";
        else if(isPpt) kind="ppt";
        else if(isXls) kind="xls";
        else if(isText) kind="text";
        const icon = (kind==="image")?"üñºÔ∏è":
                     (kind==="video")?"üéûÔ∏è":
                     (kind==="audio")?"üéµ":
                     (kind==="pdf")?"üìÑ":
                     (kind==="doc")?"üìù":
                     (kind==="ppt")?"üìä":
                     (kind==="xls")?"üìà":
                     (kind==="text")?"üßæ":"üì¶";
        return { kind, icon };
      }

      function humanBytes(n){
        const b = Number(n||0);
        if(!isFinite(b) || b<=0) return "0 B";
        const units = ["B","KB","MB","GB"];
        let i=0; let v=b;
        while(v>=1024 && i<units.length-1){ v/=1024; i++; }
        return (i===0? String(Math.round(v)) : (v<10? v.toFixed(1): v.toFixed(0))) + " " + units[i];
      }

      function makeVisionId(i){
        return "m_" + Date.now() + "_" + Math.floor(Math.random()*1e6) + "_" + i;
      }

      function renderVisionList(){
        if(!els.visionList) return;
        const bundle = state.pendingBundle;
        if(!bundle || !Array.isArray(bundle.files) || bundle.files.length===0){
          els.visionList.innerHTML = "";
          return;
        }
        const rows = bundle.files.map((f,idx)=>{
          const safeName = escapeHtml(f.name||("file_"+idx));
          const sub = `${escapeHtml(f.kind||"file")} ¬∑ ${humanBytes(f.size)} ¬∑ ${escapeHtml(f.mime||"")}`;
          const thumb = f.thumb ? `<img class="visionThumb" src="${f.thumb}" alt="thumb">` : `<div class="visionIcon">${f.icon||"üì¶"}</div>`;
          return `
            <div class="visionItem" data-idx="${idx}">
              ${thumb}
              <div class="visionMeta">
                <div class="visionName">${safeName}</div>
                <div class="visionSub">${sub}</div>
              </div>
              <div class="visionRemove" data-act="remove">Remove</div>
            </div>`;
        }).join("");
        els.visionList.innerHTML = rows;
      }

      function clearPendingBundleUI(){
        try{
          if(els.visionNote) els.visionNote.value = "";
          if(els.visionInput) els.visionInput.value = "";
          if(els.imgPrev){ els.imgPrev.src = ""; els.imgPrev.style.display = "none"; }
          if(els.vidPrev){
            try{ URL.revokeObjectURL(els.vidPrev.src||""); }catch(e){}
            els.vidPrev.src=""; els.vidPrev.style.display="none";
          }
          if(els.imagePreviewArea) els.imagePreviewArea.style.display = "none";
          if(els.visionList) els.visionList.innerHTML = "";
          if(els.visionHint) els.visionHint.textContent = "Media attached";
        }catch(e){}
        state.pendingBundle = null;
      }

      async function handleVisionFiles(files){
        const list = Array.isArray(files) ? files.filter(Boolean) : [];
        if(list.length===0) return;

        // Init bundle
        const bundleId = "bundle_" + Date.now();
        state.pendingBundle = { id: bundleId, ts: Date.now(), files: [] };

        // Reset preview UI
        if(els.imgPrev) els.imgPrev.style.display = "none";
        if(els.vidPrev){ els.vidPrev.style.display = "none"; els.vidPrev.src = ""; }
        if(els.imagePreviewArea) els.imagePreviewArea.style.display = "block";
        if(els.visionHint) els.visionHint.textContent = `${list.length} file(s) attached ¬∑ You can Save to BM`;

        // Process each file
        for(let i=0;i<list.length;i++){
          const file = list[i];
          const {kind, icon} = classifyVisionFile(file);
          const mediaId = makeVisionId(i);
          const name = file.name || (kind==="video" ? "video" : kind==="image" ? "image" : "file");
          const mime = file.type || "";
          const size = Number(file.size||0);

          let thumb = null;
          let full = null;
          let w = 0, h = 0;
          let hasBlob = false;

          try{
            // Store raw blob in IndexedDB for ALL types (if available)
            hasBlob = await idbPutBlob(mediaId, file);

            // Generate lightweight thumb for images + video posters (for preview + dream textures)
            if(kind==="image"){
              const raw = await fileToDataUrl(file);
              const thumbObj = await compressImageDataUrl(raw, 360, 0.64);
              const fullObj = await compressImageDataUrl(raw, 1100, 0.74);
              const fullBytes = dataUrlByteSize(fullObj.dataUrl);
              const keepFull = fullBytes <= 900*1024;
              thumb = thumbObj.dataUrl;
              full = keepFull ? fullObj.dataUrl : null;
              w = fullObj.w||0; h = fullObj.h||0;
              if(thumb) addDreamTextureFromDataUrl(thumb, 0.78);
            }else if(kind==="video"){
              const poster = await makeVideoPosterDataUrl(file);
              thumb = poster.dataUrl || null;
              w = poster.w||0; h = poster.h||0;
              if(thumb) addDreamTextureFromDataUrl(thumb, 0.76);
              // Show first video picked in the big preview player
              if(i===0 && els.vidPrev){
                try{
                  els.vidPrev.src = URL.createObjectURL(file);
                  els.vidPrev.style.display = "block";
                }catch(e){}
              }
            }

            // Show first image picked as big preview
            if(i===0 && kind==="image" && els.imgPrev){
              els.imgPrev.src = full || thumb || "";
              if(els.imgPrev.src){ els.imgPrev.style.display = "block"; }
            }
          }catch(e){
            showToast("Could not load one of the files");
          }

          state.pendingBundle.files.push({ id: mediaId, ts: Date.now(), kind, icon, name, mime, size, w, h, thumb, full, hasBlob });
        }

        renderVisionList();
        logLine("sys",`[Vision] ${list.length} file(s) attached as a BM bundle. Save to BM to keep reference.`);
      }
      if(els.btnVisionPick && els.visionInput){
        els.btnVisionPick.addEventListener("click", ()=>{ try{ els.visionInput.click(); }catch(e){} });
      }



      if(els.visionInput){
        els.visionInput.addEventListener("change", async ()=>{
          const input = els.visionInput;
          const files = input?.files ? Array.from(input.files) : [];
          if(files.length){
            await handleVisionFiles(files);
          }
        });
      }

      // Remove file from pending bundle
      if(els.visionList){
        els.visionList.addEventListener("click",(ev)=>{
          const act = ev?.target?.getAttribute?.("data-act");
          if(act!=="remove") return;
          const itemEl = ev.target.closest(".visionItem");
          const idx = Number(itemEl?.getAttribute?.("data-idx"));
          if(!state.pendingBundle || !Array.isArray(state.pendingBundle.files)) return;
          if(!isFinite(idx) || idx<0 || idx>=state.pendingBundle.files.length) return;
          state.pendingBundle.files.splice(idx,1);
          renderVisionList();
          if(els.visionHint){
            const n = state.pendingBundle.files.length;
            els.visionHint.textContent = n ? `${n} file(s) attached ¬∑ You can Save to BM` : "Media attached";
          }
          if(state.pendingBundle.files.length===0){
            clearPendingBundleUI();
          }
          showToast("Removed");
        });
      }

      if(els.saveVisionToBM){
        els.saveVisionToBM.addEventListener("click", ()=>{
          savePendingVisionToBM();
          // Clear UI + close box (bundle + single)
          if(els.visionNote) els.visionNote.value = "";
          if(els.visionInput) els.visionInput.value = "";
          if(els.imgPrev){ els.imgPrev.src = ""; els.imgPrev.style.display = "none"; }
          if(els.vidPrev){ try{ URL.revokeObjectURL(els.vidPrev.src||""); }catch(e){} els.vidPrev.src=""; els.vidPrev.style.display="none"; }
          if(els.imagePreviewArea) els.imagePreviewArea.style.display = "none";
          if(els.visionList) els.visionList.innerHTML = "";
          state.pendingVision = null;
          state.pendingBundle = null;
          try{ els.userInput && els.userInput.focus(); }catch(e){}
        });
      }
      /* Main chat + self-learning pipeline */
      async function handleSend(){
        const raw = els.userInput.value;
        let text = raw.trim();
        if(!text) return;
        // If a media is attached, add a stable tag to the prompt (offline-friendly)
        if(state.pendingVision){ text = attachPendingVisionToPromptText(text); }

        els.userInput.value = "";
        els.optionsMenu.classList.remove("show");
        if(state.correcting){
          const correctA = text;
          if(state.lastUserQ && correctA){
            const id = "intel_"+Date.now();
            state.intelligence.push({ id, q: state.lastUserQ, a: correctA, ts: Date.now() });
            saveIntelligence();
            renderIntelligence(els.intelSearch.value);
            logLine("sys","[Self-learning] Stored corrected answer into intelligence.");
            showToast("Correct answer stored");
          }
          state.correcting = false;
          return;
        }
        logLine("user","You: "+text);
        registerActivity();
        const now = Date.now();
        if(state.cooldownUntil && now < state.cooldownUntil){
          logLine("sys","[Cooldown] Please wait a moment before sending more messages.");
          return;
        }
        state.metrics.TM = scoreTM(text);
        recomputeBMMetric();
        let intelBoost = 0, llmBoost = 0;
        let answer = null;
        let source = "none";
        const tLower = text.toLowerCase();
        let bestMatch = state.intelligence.find(p=>p.q.toLowerCase()===tLower);
        if(!bestMatch){
          bestMatch = state.intelligence.find(p=>tLower.includes(p.q.toLowerCase()) || p.q.toLowerCase().includes(tLower));
        }
        if(bestMatch){
          answer = bestMatch.a;
          source = "intelligence";
          intelBoost = 0.35;
        }
        if(!answer && state.seedPairs.length){
          let sMatch = state.seedPairs.find(p=>p.q.toLowerCase()===tLower);
          if(!sMatch){
            sMatch = state.seedPairs.find(p=>tLower.includes(p.q.toLowerCase()) || p.q.toLowerCase().includes(tLower));
          }
          if(sMatch){
            answer = sMatch.a;
            source = "seed";
            intelBoost = 0.25;
          }
        }
        if(!answer && state.offlineReady){
          answer = await callOfflineLLM(text);
          if(answer){
            source = "offline";
            llmBoost = 0.25;
          }
        }
        if(!answer){
          answer = await callOnlineLLM(text);
          if(answer){
            source = "online";
            llmBoost = 0.30;
          }
        }
        if(!answer){
          answer = "I don't have a stored answer yet. You can teach me using the üëé button or by adding LaTeX blocks under Feed the seed.";
          source = "fallback";
        }
        state.lastUserQ = text;
        state.lastAuraA = answer;
        state.lastAnswerSource = source;
        recomputeE0(intelBoost, llmBoost);
        updateCapsule();
        logLine("aura","AURA: "+answer+"  (source: "+source+")");
        if(state.voiceOn){
          try{
            const u = new SpeechSynthesisUtterance(answer);
            const e0 = state.metrics.E0;
            let rate = 1, pitch = 1;
            if(e0 > 0.3){
              const t = Math.min((e0-0.3)*2,1);
              rate = 1.05 + 0.3*t;
              pitch = 1.05 + 0.3*t;
            }else if(e0 < -0.3){
              const t = Math.min((Math.abs(e0)-0.3)*2,1);
              rate = 0.95 - 0.25*t;
              pitch = 0.95 - 0.35*t;
            }
            u.rate = Math.max(0.6,Math.min(rate,1.6));
            u.pitch = Math.max(0.5,Math.min(pitch,1.8));
            speechSynthesis.speak(u);
          }catch{}
        }
        // After first answer with faith ON -> golden bar flies to top
        if(state.faithSelection.length && state.faithFlightPending && !state.faithFlightDone){
          startFaithFlight();
        }
        updateEthicBar(text);
      }
      els.sendBtn.addEventListener("click",handleSend);
      els.userInput.addEventListener("keydown",e=>{
        if(e.key==="Enter" && !e.shiftKey){
          e.preventDefault();
          handleSend();
        }
      });
      function interceptIncorrect(text){
        return text.trim().toLowerCase()==="incorrect";
      }
      els.userInput.addEventListener("keydown",e=>{
        if(e.key==="Enter" && !e.shiftKey){
          const val = els.userInput.value.trim();
          if(interceptIncorrect(val) && state.lastUserQ && state.lastAuraA){
            e.preventDefault();
            els.userInput.value = "";
            logLine("user","You: incorrect");
            logLine("sys","[Self-learning] Please type the correct answer for the last question.");
            state.correcting = true;
            return;
          }
        }
      });
      /* Reaction buttons */
      els.btnLikeLast.addEventListener("click",()=>{
        if(!state.lastUserQ || !state.lastAuraA){
          showToast("No last answer to save");
          return;
        }
        const already = state.intelligence.find(p=>p.q===state.lastUserQ && p.a===state.lastAuraA);
        if(already){
          showToast("Already in intelligence");
          return;
        }
        const id = "intel_"+Date.now();
        state.intelligence.push({id,q:state.lastUserQ,a:state.lastAuraA,ts:Date.now()});
        saveIntelligence();
        renderIntelligence(els.intelSearch.value);
        showToast("Saved to intelligence");
      });
      els.btnDislikeLast.addEventListener("click",()=>{
        if(!state.lastUserQ || !state.lastAuraA){
          showToast("No last answer");
          return;
        }
        logLine("sys","[Self-learning] Type the correct answer in chat. It will replace the last one.");
        state.correcting = true;
      });
      els.btnSpeakLast.addEventListener("click",()=>{
        if(!state.lastAuraA){
          showToast("No last answer");
          return;
        }
        try{
          const u = new SpeechSynthesisUtterance(state.lastAuraA);
          speechSynthesis.speak(u);
        }catch{}
      });
      els.btnShareLast.addEventListener("click",()=>{
        if(!state.lastUserQ || !state.lastAuraA){
          showToast("No last pair");
          return;
        }
        const text = `Q: ${state.lastUserQ}\nA: ${state.lastAuraA}`;
        navigator.clipboard?.writeText(text);
        showToast("Question + answer copied");
      });
      document.addEventListener("click", ()=>registerActivity(), true);
      document.addEventListener("keydown", ()=>registerActivity(), true);

      /* =========================
         Sense (Camera + Mic) ‚Üí BM stub
         ========================= */
      function setSensePill(text, mode){
        if(els.sensePill){
          els.sensePill.textContent = text;
          if(mode==="rec"){ els.sensePill.className = "pillOff"; }
          else if(mode==="ok"){ els.sensePill.className = "pillOn"; }
          else { els.sensePill.className = "pillMid"; }
        }
        if(els.senseStatus){
          els.senseStatus.textContent = text ? (text[0].toUpperCase()+text.slice(1) + ".") : "Idle.";
        }
      }

      function cleanupSense(){
        try{
          if(state.sense && state.sense.mediaRecorder && state.sense.mediaRecorder.state==="recording"){
            state.sense.mediaRecorder.stop();
          }
        }catch{}
        try{
          if(state.sense && state.sense.stream){
            state.sense.stream.getTracks().forEach(t=>t.stop());
            state.sense.stream = null;
          }
        }catch{}
        if(els.senseVideo){
          try{ els.senseVideo.srcObject = null; }catch{}
          els.senseVideo.style.display = "none";
        }
        if(state.sense){
          state.sense.mediaRecorder = null;
          state.sense.chunks = [];
          state.sense.busy = false;
        }
        setSensePill("idle","mid");
      }

      async function startSenseCamera(){
        if(!els.senseVideo || !els.senseCanvas || !els.senseBMBox){ return; }
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          showToast("Camera not available in this browser");
          return;
        }
        if(state.sense.busy){ showToast("Sense is busy"); return; }
        state.sense.busy = true;
        setSensePill("camera on","ok");
        try{
          const stream = await navigator.mediaDevices.getUserMedia({video:true,audio:false});
          state.sense.stream = stream;
          els.senseVideo.srcObject = stream;
          els.senseVideo.style.display = "block";
          if(els.senseStatus) els.senseStatus.textContent = "Camera on. Capturing snapshot in 2 seconds‚Ä¶";
          setTimeout(()=>captureSenseSnapshot(),2000);
        }catch(err){
          console.warn(err);
          showToast("Camera permission denied or error");
          state.sense.busy = false;
          setSensePill("idle","mid");
        }
      }

      function captureSenseSnapshot(){
        if(!state.sense.stream) return;
        const video = els.senseVideo;
        const canvas = els.senseCanvas;
        const w = video.videoWidth || 320;
        const h = video.videoHeight || 240;
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(video,0,0,w,h);

        // NOTE: We keep only a stub text in BM, not the image itself (privacy + storage).
        // Developer can plug a vision API here if needed.
        const stub =
`Sense snapshot BM stub:
- Time: ${new Date().toLocaleString()}
- Source: camera snapshot
- Developer TODO: run vision analysis (people/objects/scene/mood) and summarise.
- Emotional guess: calm / neutral until analysed.`;

        els.senseBMBox.value = stub;

        // stop camera
        cleanupSense();
        state.sense.busy = false;
        setSensePill("ready","ok");
        if(els.senseStatus) els.senseStatus.textContent = "Snapshot captured locally. Edit the stub and Save to BM.";
      }

      async function startSenseMic(){
        if(!els.senseBMBox){ return; }
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
          showToast("Microphone not available in this browser");
          return;
        }
        if(state.sense.busy){ showToast("Sense is busy"); return; }
        state.sense.busy = true;
        setSensePill("recording","rec");
        try{
          const stream = await navigator.mediaDevices.getUserMedia({audio:true,video:false});
          state.sense.stream = stream;
          state.sense.chunks = [];
          const rec = new MediaRecorder(stream);
          state.sense.mediaRecorder = rec;
          if(els.senseStatus) els.senseStatus.textContent = "Recording 10 seconds‚Ä¶";
          rec.ondataavailable = e => { if(e.data) state.sense.chunks.push(e.data); };
          rec.onstop = ()=>{
            try{ stream.getTracks().forEach(t=>t.stop()); }catch{}
            state.sense.stream = null;
            const blob = new Blob(state.sense.chunks,{type:"audio/webm"});
            const kb = Math.round(blob.size/1024);
            const prev = (els.senseBMBox.value||"").trim();
            const stub =
`Audio sample BM stub:
- Time: ${new Date().toLocaleString()}
- Source: ~10s microphone sample (~${kb} KB)
- Developer TODO: run speech-to-text + emotion (pitch/intensity/speaker count).`;

            els.senseBMBox.value = (prev ? (prev+"\n\n") : "") + stub;
            state.sense.chunks = [];
            state.sense.busy = false;
            setSensePill("ready","ok");
            if(els.senseStatus) els.senseStatus.textContent = "Audio captured. Edit stub and Save to BM.";
          };
          rec.start();
          setTimeout(()=>{ if(rec.state==="recording") rec.stop(); },10000);
        }catch(err){
          console.warn(err);
          showToast("Mic permission denied or error");
          state.sense.busy = false;
          setSensePill("idle","mid");
        }
      }

      function saveSenseStubToBM(){
        const text = (els.senseBMBox && els.senseBMBox.value || "").trim();
        if(!text){ showToast("Nothing to save"); return; }
        const id = "bm_"+Date.now();
        const title = "Sense capture";
        state.bmPrompts.push({
          id,
          title,
          text,
          ts: Date.now(),
          locked: true
        });
        saveBM();
        recomputeBMMetric();
        recomputeE0(0,0);
        updateCapsule();
        renderBMList();
        showToast("Saved to BM");
        if(els.senseBMBox) els.senseBMBox.value = "";
        setSensePill("idle","mid");
      }

      if(els.btnSenseCamera) els.btnSenseCamera.addEventListener("click", startSenseCamera);
      if(els.btnSenseMic) els.btnSenseMic.addEventListener("click", startSenseMic);
      if(els.btnSaveSenseBM) els.btnSaveSenseBM.addEventListener("click", saveSenseStubToBM);

      /* Load from localStorage on start */
      function initFromStorage(){
        const cfg = safeLoadJSON(KEY_CFG,null);
        if(cfg){
          state.voiceOn = !!cfg.voiceOn;
          state.learningOn = cfg.learningOn!==false;
          state.faithSelection = cfg.faithSelection||[];
          state.faithLiveOptions = cfg.faithLiveOptions || {};
          state.apiConfig = cfg.apiConfig||state.apiConfig;
          state.offlineReady = !!cfg.offlineReady;
          if(cfg.dream){
            state.dreamEnabled = !!cfg.dream.enabled;
            state.dreamDelayMs = cfg.dream.delayMs || state.dreamDelayMs;
            if(cfg.dream.intensityThreshold!=null) state.dreamCfg.intensityThreshold = Number(cfg.dream.intensityThreshold)||state.dreamCfg.intensityThreshold;
            if(cfg.dream.glimpseEveryMs!=null) state.dreamCfg.glimpseEveryMs = Number(cfg.dream.glimpseEveryMs)||state.dreamCfg.glimpseEveryMs;
            if(cfg.dream.glimpseHoldMs!=null) state.dreamCfg.glimpseHoldMs = Number(cfg.dream.glimpseHoldMs)||state.dreamCfg.glimpseHoldMs;
          }
          if(cfg.intuition){
            state.intuition.enabled = !!cfg.intuition.enabled;
            state.intuition.lastRun = Number(cfg.intuition.lastRun)||0;
            state.intuition.captureIntervalMin = Number(cfg.intuition.captureIntervalMin)||state.intuition.captureIntervalMin;
            state.intuition.cameraEnabled = cfg.intuition.cameraEnabled!==false;
            state.intuition.micEnabled = !!cfg.intuition.micEnabled;
          }
        }
        els.voicePill.textContent = state.voiceOn ? "on" : "off";
        els.voicePill.className = state.voiceOn ? "pillOn" : "pillOff";
        els.learnPill.textContent = state.learningOn ? "on" : "off";
        els.learnPill.className = state.learningOn ? "pillOn" : "pillOff";
        state.intelligence = safeLoadJSON(KEY_INT,[]);
        state.bmPrompts = safeLoadJSON(KEY_BM,[]);
        state.history = safeLoadJSON(KEY_HIST,[]);
        state.userIdentity = safeLoadJSON(KEY_USER,null);
        state.senseGallery = safeLoadJSON(KEY_SENSEG,[]);
        hydrateDreamTexturesFromSense();
        loadIntuitionLog();
        const logicStored = safeLoadJSON(KEY_LOGIC,null);
        if(logicStored){
          state.logicPacks = logicStored.list||[];
          state.logicActiveIndex = logicStored.activeIndex;
          if(state.logicActiveIndex!=null) applyLogicPack(state.logicActiveIndex);
        }
        if(state.apiConfig.endpoint) els.apiEndpoint.value = state.apiConfig.endpoint;
        if(state.apiConfig.model) els.apiModel.value = state.apiConfig.model;
        if(state.apiConfig.key) els.apiKey.value = state.apiConfig.key;
        renderFaithChips();
        onFaithChanged();
        renderIntelligence("");
        renderBMList();
        renderHistory();
        loadIdentityIntoForm();
        recomputeBMMetric();
        recomputeE0(0,0);
        updateCapsule();
        updateDreamUI();
        scheduleDreamTimer();
        setEthicText(ETHIC_BASE,""); // ‚úÖ no meta
      }
      initFromStorage();
      attachHiddenIntuitionToggle();
      startIntuitionTimer();
      logLine("sys","AURA-X Œ© ready. TM = your inputs only; everything else stays on this device.");
    });
  </script>
</body>
</html>